/**
 * wave-effect.tuned-slower-major.js
 * Purpose: significantly slow the ripple expansion (transform) compared to prior builds,
 * while preserving all public APIs, class names, CSS variable names and event handlers.
 *
 * Implementation notes:
 * - INTERNAL_SPEED_MULTIPLIER > 1 now slows the visual expansion. JS still computes base duration
 *   (smartDuration) and writes scaled value to --ripple-duration so CSS transitions remain authoritative.
 * - Pooling, rAF batching, will-change only during active phases, and concurrent ripples are preserved.
 * - External tuning via :root { --ripple-duration-multiplier: ... } is still read and combined.
 */
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = factory();
  } else {
    root.WakeEffect = factory();
  }
}(typeof self !== 'undefined' ? self : this, function() {
  'use strict';

  // --- Constants ---
  const RIPPLE_CLASS = 'ripple',
    SURFACE_CLASS = 'ripple-surface',
    BASE_DURATION = 370,
    MIN_DURATION = 290,
    MAX_EXTRA = 0.3,
    MIN_RIPPLE_INTERVAL = 0,
    GLOBAL_MIN_RIPPLE_INTERVAL = 60,
    GLOBAL_MAX_RIPPLES = 5,
    RIPPLE_HALO_START_DIAMETER = 18,
    RIPPLE_HALO_BLUR = 0.6,
    COVERAGE_EXPAND_RATIO = 0.21,
    MAX_RIPPLES_PER_ELEMENT = 6,
    SCROLL_VELOCITY_THRESHOLD = 1.6,
    SCROLL_DISTANCE_THRESHOLD = 18,
    SCROLL_TIME_WINDOW = 65,
    FINE_SCROLL_THRESHOLD = 0.40;

  // --- Visual slowdown tweak (internal only) ---
  // Set >1 to slow the expansion. For a noticeable, professional slower feel use 1.3-1.6.
  // This build uses 1.45 to slow the expansion "พอสมควร" as requested.
  const INTERNAL_SPEED_MULTIPLIER = 1;

  // --- State ---
  let RIPPLE_FADE_DURATION_AUTO = 1200,
    RIPPLE_FADE_DURATION_MANUAL = 500,
    lastGlobalRippleTime = 0,
    waveSettingLoaded = false,
    waveJsonLoaded = false,
    waveEffectCSSLoaded = false,
    lastUpgradeAll = 0,
    cachedWaveNodes = [],
    tapHighlightInjected = false,
    lastScrollTime = 0,
    isRapidScrolling = false,
    lastTouchTime = 0, lastTouchY = 0, lastTouchX = 0, lastTouchMoveY = 0, lastTouchMoveX = 0,
    touchMoved = false, touchMoveHistory = [], ignoreNextRipple = false,
    observer,
    upgradeAllTimer = null;

  // --- Object caches (reuse object instead of allocation) ---
  const lastAllowed = new WeakMap(),
    activeRipples = new WeakMap(),
    ripplePools = new WeakMap(),
    upgradedElements = new WeakSet(),
    rectCache = new WeakMap(),
    settings = { disableTapHighlight: false };

  // Lightweight caches
  const defaultColorCache = new WeakMap();
  const DEFAULT_COLOR_CACHE_TTL = 1200; // ms

  // Cache for external CSS multiplier to avoid frequent style reads
  let externalMultiplierCache = { time: 0, val: 1 };
  const EXTERNAL_MULTIPLIER_TTL = 1200; // ms

  // --- Utility ---
  const now = () => performance.now();

  function getExternalDurationMultiplier() {
    const t = Date.now();
    if ((t - externalMultiplierCache.time) < EXTERNAL_MULTIPLIER_TTL) return externalMultiplierCache.val;
    try {
      const style = getComputedStyle(document.documentElement);
      const raw = style.getPropertyValue('--ripple-duration-multiplier').trim();
      let v = parseFloat(raw);
      if (!isFinite(v) || v <= 0) v = 1;
      externalMultiplierCache.time = t;
      externalMultiplierCache.val = v;
      return v;
    } catch (e) {
      return 1;
    }
  }

  // --- DOM query cache ---
  function querySelectorAllCached(sel) {
    const time = Date.now();
    if (sel === '[wave]' && (time - lastUpgradeAll < 1800) && cachedWaveNodes.length)
      return cachedWaveNodes;
    const nodeList = document.querySelectorAll(sel);
    const nodes = Array.prototype.slice.call(nodeList);
    if (sel === '[wave]') {
      cachedWaveNodes = nodes;
      lastUpgradeAll = time;
    }
    return nodes;
  }

  // --- Scroll/Touch handlers (lightweight) ---
  window.addEventListener('scroll', (() => {
    let scrollTimer;
    return function() {
      const n = now();
      if (n - lastScrollTime < 40) {
        isRapidScrolling = true;
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => { isRapidScrolling = false; }, 88);
      }
      lastScrollTime = n;
    };
  })(), { passive: true });

  function onTouchStart(e) {
    const t = e.touches?.[0] || e;
    lastTouchTime = now();
    lastTouchX = t.clientX;
    lastTouchY = t.clientY;
    lastTouchMoveX = lastTouchX;
    lastTouchMoveY = lastTouchY;
    touchMoveHistory.length = 0;
    touchMoveHistory.push({ t: lastTouchTime, x: lastTouchX, y: lastTouchY });
    touchMoved = false;
    ignoreNextRipple = false;
  }
  function onTouchMove(e) {
    const t = e.touches?.[0] || e,
      n = now(), dx = t.clientX - lastTouchMoveX, dy = t.clientY - lastTouchMoveY;
    touchMoved = touchMoved || (Math.abs(dx) > SCROLL_DISTANCE_THRESHOLD || Math.abs(dy) > SCROLL_DISTANCE_THRESHOLD);
    lastTouchMoveX = t.clientX; lastTouchMoveY = t.clientY;
    touchMoveHistory.push({ t: n, x: t.clientX, y: t.clientY });
    if (touchMoveHistory.length > 7) touchMoveHistory.shift();
    let b = 0;
    for (let i = touchMoveHistory.length - 2; i >= 0; i--) {
      if (n - touchMoveHistory[i].t > SCROLL_TIME_WINDOW) { b = i; break; }
    }
    const base = touchMoveHistory[b], main = touchMoveHistory[touchMoveHistory.length - 1], dt = main.t - base.t;
    if (dt > 10) {
      const v = Math.hypot(main.x - base.x, main.y - base.y) / dt;
      if (v > SCROLL_VELOCITY_THRESHOLD) ignoreNextRipple = true;
    }
  }
  function onTouchEnd() {
    if (touchMoved && touchMoveHistory.length >= 2) {
      const first = touchMoveHistory[0], last = touchMoveHistory[touchMoveHistory.length - 1];
      const v = Math.hypot(last.x - first.x, last.y - first.y) / (last.t - first.t);
      if (v > FINE_SCROLL_THRESHOLD) ignoreNextRipple = true;
    }
    touchMoveHistory.length = 0;
    lastTouchTime = 0;
    lastTouchX = lastTouchY = 0;
    touchMoved = false;
  }

  // --- rAF batcher ---
  const rippleQueue = [];
  let rippleRAF = null;
  function scheduleRipple(fn) {
    rippleQueue.push(fn);
    if (!rippleRAF) {
      rippleRAF = requestAnimationFrame(() => {
        for (let i = 0; i < rippleQueue.length; i++) rippleQueue[i]();
        rippleQueue.length = 0;
        rippleRAF = null;
      });
    }
  }

  // --- Ripple pool ---
  function getRippleNode(el) {
    let pool = ripplePools.get(el);
    if (!pool) pool = [], ripplePools.set(el, pool);
    let node = pool.pop();
    if (!node) {
      node = document.createElement('span');
      node.className = RIPPLE_CLASS + ' dynamic-halo-pro';
      node.style.contain = 'strict';
    }
    node.classList.remove('animating', 'fading');
    node.style.cssText = '';
    node.style.display = 'block';
    return node;
  }
  function releaseRippleNode(el, node) {
    node.classList.remove('animating', 'fading');
    node.style.opacity = 0;
    node.style.removeProperty('will-change');
    requestAnimationFrame(() => {
      node.style.display = 'none';
      if (node.parentNode === el) el.removeChild(node);
      let pool = ripplePools.get(el);
      if (!pool) pool = [], ripplePools.set(el, pool);
      if (pool.length < MAX_RIPPLES_PER_ELEMENT) pool.push(node);
    });
  }

  // --- CSS / settings loader helpers ---
  function autoLoadWaveEffectCSS() {
    if (waveEffectCSSLoaded) return;
    const cssPath = 'https://marcufer.github.io/Marcumat.js/assets/wave-effect.min.css';
    for (const link of document.querySelectorAll('link[rel="stylesheet"]')) {
      if (link.href && link.href.indexOf(cssPath) !== -1) { waveEffectCSSLoaded = true; return; }
    }
    if (!document.querySelector(`link[href="${cssPath}"]`)) {
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = cssPath;
      link.onload = () => { waveEffectCSSLoaded = true; };
      link.onerror = () => { waveEffectCSSLoaded = false; };
      document.head.appendChild(link);
    }
  }
  function makeMultifyCandidates(base, exts) {
    let out = [];
    for (let ext of exts) {
      if (base.endsWith(ext)) { out.push(base.replace(ext, `.min${ext}`)); out.push(base); }
    }
    return out;
  }
  function autoLoadWaveSettingCSS() {
    if (waveSettingLoaded) return;
    for (const link of document.querySelectorAll('link[rel="stylesheet"]')) {
      if (link.href && /wave-setting(\.min)?\.css([?#].*)?$/i.test(link.href)) { waveSettingLoaded = true; return; }
    }
    const pathBases = ['/wave-setting.css', '/css/wave-setting.css', '/assets/wave-setting.css'];
    let candidates = [];
    for (const base of pathBases) { candidates = candidates.concat(makeMultifyCandidates(base, [".css"])); }
    const thisScript = document.currentScript || Array.from(document.scripts).find(s => /wave-effect(\.min)?\.js$/i.test(s.src));
    if (thisScript && thisScript.src) {
      try {
        const url = new URL(thisScript.src, location.href);
        url.pathname = url.pathname.replace(/[^/]+$/, 'wave-setting.css');
        candidates = candidates.concat(makeMultifyCandidates(url.pathname, [".css"]));
      } catch { }
    }
    (function tryNext(idx) {
      if (idx >= candidates.length) return;
      const href = candidates[idx];
      if (document.querySelector(`link[href="${href}"]`)) return tryNext(idx + 1);
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = href;
      link.onload = () => { waveSettingLoaded = true; };
      link.onerror = () => { tryNext(idx + 1); };
      document.head.appendChild(link);
    })(0);
  }
  function autoLoadWaveSettingJSON(callback) {
    if (waveJsonLoaded) { if (callback) callback(settings); return; }
    const pathBases = ['/wave-setting.json', '/css/wave-setting.json', '/assets/wave-setting.json'];
    let candidates = [];
    for (const base of pathBases) { candidates = candidates.concat(makeMultifyCandidates(base, [".json"])); }
    const thisScript = document.currentScript || Array.from(document.scripts).find(s => /wave-effect(\.min)?\.js$/i.test(s.src));
    if (thisScript && thisScript.src) {
      try {
        const url = new URL(thisScript.src, location.href);
        url.pathname = url.pathname.replace(/[^/]+$/, 'wave-setting.json');
        candidates = candidates.concat(makeMultifyCandidates(url.pathname, [".json"]));
      } catch { }
    }
    (function tryNext(idx) {
      if (idx >= candidates.length) { waveJsonLoaded = true; if (callback) callback(settings); return; }
      fetch(candidates[idx], { method: 'GET', credentials: 'same-origin' })
        .then(r => r.ok ? r.json() : null)
        .then(json => {
          if (json && typeof json === 'object') {
            waveJsonLoaded = true; Object.assign(settings, json);
            if (callback) callback(settings);
          } else { tryNext(idx + 1); }
        })
        .catch(() => tryNext(idx + 1));
    })(0);
  }

  // --- Tap highlight ---
  function injectTapHighlightCSS() {
    if (tapHighlightInjected) return;
    if (document.querySelector('[data-wave-tap-highlight="true"]')) { tapHighlightInjected = true; return; }
    const style = document.createElement("style");
    style.setAttribute("data-wave-tap-highlight", "true");
    style.textContent = `[wave]{-webkit-tap-highlight-color:transparent!important;tap-highlight-color:transparent!important;}`;
    document.head.appendChild(style);
    tapHighlightInjected = true;
  }

  // --- Ripple color with small cache ---
  function getDefaultRippleColor(el) {
    const cached = defaultColorCache.get(el);
    const t = now();
    if (cached && (t - cached.time) < DEFAULT_COLOR_CACHE_TTL) return cached.val;

    let node = el, found = null;
    while (node) {
      const style = getComputedStyle(node);
      const val = style.getPropertyValue('--ripple-default-color').trim();
      if (val) { found = val; break; }
      node = node.parentElement;
    }
    defaultColorCache.set(el, { val: found, time: t });
    return found;
  }
  function getRippleColor(el) {
    if (el.hasAttribute('data-ripple-color')) {
      let val = el.getAttribute('data-ripple-color').trim();
      if (val) return val;
    }
    const attr = el.getAttribute("wave") || "";
    let m = attr.match(/(?:^|\s)c\s*[=:]?\s*([#a-zA-Z0-9(),.\s]+)/i);
    if (m && m[1]) {
      let val = m[1].trim();
      if (val) return val;
    }
    let def = getDefaultRippleColor(el);
    if (def) return def;
    return null;
  }
  function getRippleBg(color) {
    const defaultC = [16, 20, 28];
    if (color) {
      if (/^rgba?\([^)]+\)$/i.test(color) || /^hsla?\([^)]+\)$/i.test(color)) {
        let main = color.replace(/\s+/g, ''), inside = main.match(/\(([^)]+)\)/);
        if (inside) {
          let parts = inside[1].split(','),
            alpha = parts[3] !== undefined ? parseFloat(parts[3]) : 1,
            p1 = Math.min(1, Math.max(alpha, 0.13)),
            p2 = Math.max(0, 0.15 * p1),
            p3 = Math.max(0, 0.09 * p1),
            c1 = parts.slice(0, 3).join(',') + ',' + p1,
            c2 = parts.slice(0, 3).join(',') + ',' + p2,
            c3 = parts.slice(0, 3).join(',') + ',' + p3,
            prefix = color.startsWith('hsla') ? 'hsla' : (color.startsWith('hsl') ? 'hsla' : 'rgba');
          return `radial-gradient(circle, ${prefix}(${c1}) 62%, ${prefix}(${c2}) 74%, ${prefix}(${c3}) 100%)`;
        }
      }
      return `radial-gradient(circle, ${color}21 62%, ${color}13 74%, ${color}03 100%)`;
    }
    return `radial-gradient(circle, rgba(${defaultC[0]},${defaultC[1]},${defaultC[2]},0.13) 62%, rgba(${defaultC[0]},${defaultC[1]},${defaultC[2]},0.078) 74%, rgba(${defaultC[0]},${defaultC[1]},${defaultC[2]},0.03) 100%)`;
  }

  // --- Geometry & animation helpers ---
  function maximalExpandedCoverageRadius(x, y, width, height) {
    let dists = [
      x, y, width - x, height - y,
      Math.hypot(x, y), Math.hypot(width - x, y), Math.hypot(x, height - y), Math.hypot(width - x, height - y),
      Math.abs(width / 2 - x), Math.abs(height / 2 - y), Math.hypot(width, height) / 2
    ];
    let maxDist = Math.max.apply(null, dists);
    let expand = Math.max(width, height) * COVERAGE_EXPAND_RATIO;
    let minRadius = 28;
    return Math.max(maxDist * Math.SQRT2 + expand, minRadius);
  }
  function smartBlur() { return `blur(${RIPPLE_HALO_BLUR}px)`; }
  function smartDuration(x, y, width, height) {
    const cx = width / 2, cy = height / 2,
      maxDist = maximalExpandedCoverageRadius(cx, cy, width, height),
      pointerDist = Math.hypot(x - cx, y - cy),
      ratio = Math.min(pointerDist / maxDist, 1),
      duration = BASE_DURATION - (BASE_DURATION - MIN_DURATION) * (ratio * MAX_EXTRA);
    return Math.round(duration);
  }

  function fadeOutAndRemoveRipple(ripple, fadeType, el) {
    if (!ripple) return;
    let duration = (fadeType === 'auto' ? RIPPLE_FADE_DURATION_AUTO : RIPPLE_FADE_DURATION_MANUAL);
    ripple.classList.add('fading');
    ripple.style.setProperty('--ripple-fade-duration', duration + 'ms');
    ripple.style.willChange = 'opacity,transform,filter';
    let removed = false;
    function removeRippleAfterFade(e) {
      if (removed) return;
      if (!e || e.propertyName === "opacity") {
        removed = true;
        ripple.removeEventListener('transitionend', removeRippleAfterFade);
        ripple.style.removeProperty('will-change');
        try {
          const set = activeRipples.get(el);
          if (set && set.delete) set.delete(ripple);
        } catch (err) { }
        releaseRippleNode(el, ripple);
      }
    }
    ripple.addEventListener('transitionend', removeRippleAfterFade);
    setTimeout(removeRippleAfterFade, duration + 80);
  }

  function clearRipples(el) {
    const ripples = el.querySelectorAll('.' + RIPPLE_CLASS);
    for (let i = 0; i < ripples.length; i++) { fadeOutAndRemoveRipple(ripples[i], 'manual', el); }
    activeRipples.set(el, new Set());
  }

  // always allow ripple creation
  function allowGlobalRipple() { return true; }

  function getRect(el) {
    let cached = rectCache.get(el),
      n = now();
    if (!cached || (n - cached.time > 800)) {
      cached = { rect: el.getBoundingClientRect(), time: n };
      rectCache.set(el, cached);
    }
    return cached.rect;
  }
  function animateRipple(ripple, scale) {
    ripple.style.willChange = 'transform, opacity, filter';
    ripple.style.transform = `scale(${scale}) translate3d(0,0,0)`;
    ripple.style.backfaceVisibility = 'hidden';
    setTimeout(() => {
      try { ripple.style.removeProperty('will-change'); } catch (e) {}
    }, 520);
  }

  // --- Main pointer handler ---
  function onPointerDown(e) {
    if (isRapidScrolling || ignoreNextRipple) return;
    if (e.button && e.button !== 0) return;
    const el = this;
    if (!allowGlobalRipple()) return;
    const n = now();
    lastAllowed.set(el, n);
    scheduleRipple(() => {
      const rect = getRect(el),
        pointer = e.touches?.[0] || e,
        x = pointer.clientX - rect.left,
        y = pointer.clientY - rect.top,
        radius = maximalExpandedCoverageRadius(x, y, rect.width, rect.height),
        haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER,
        baseDuration = smartDuration(x, y, rect.width, rect.height),
        // apply internal slowdown (>1) and optional external multiplier
        scaledDuration = Math.max(120, Math.round(baseDuration * INTERNAL_SPEED_MULTIPLIER * getExternalDurationMultiplier())),
        colorVal = getRippleColor(el),
        bg = getRippleBg(colorVal),
        ripple = getRippleNode(el);

      ripple.style.width = ripple.style.height = RIPPLE_HALO_START_DIAMETER + 'px';
      ripple.style.left = (x - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      ripple.style.top = (y - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      ripple.style.setProperty('--ripple-duration', scaledDuration + 'ms');
      ripple.style.setProperty('--ripple-blur', smartBlur());
      ripple.style.background = bg;
      ripple.style.setProperty('--ripple-final-scale', haloFinalScale);
      ripple.style.transform = 'scale(1) translate3d(0,0,0)';
      ripple.style.backfaceVisibility = 'hidden';
      el.appendChild(ripple);

      let set = activeRipples.get(el);
      if (!set) {
        set = new Set();
        activeRipples.set(el, set);
      }
      set.add(ripple);

      let animationEnded = false, autoFadeTimeout = null;
      function endRipple() {
        if (!ripple.parentNode) return;
        if (!animationEnded) fadeOutAndRemoveRipple(ripple, 'auto', el);
        else fadeOutAndRemoveRipple(ripple, 'manual', el);
        try { if (set && set.delete) set.delete(ripple); } catch (err) {}
        if (autoFadeTimeout) clearTimeout(autoFadeTimeout);
        el.removeEventListener('pointerup', endRipple);
        el.removeEventListener('pointerleave', endRipple);
        el.removeEventListener('touchend', endRipple);
        el.removeEventListener('touchcancel', endRipple);
      }
      el.addEventListener('pointerup', endRipple, { passive: true, once: true });
      el.addEventListener('pointerleave', endRipple, { passive: true, once: true });
      el.addEventListener('touchend', endRipple, { passive: true, once: true });
      el.addEventListener('touchcancel', endRipple, { passive: true, once: true });
      requestAnimationFrame(() => {
        ripple.classList.add('animating');
        animateRipple(ripple, haloFinalScale);
        setTimeout(() => { animationEnded = true; }, scaledDuration);
      });
      autoFadeTimeout = setTimeout(() => { }, scaledDuration + 32);
    });
    ignoreNextRipple = false;
  }

  function onKeyDown(e) {
    if (![' ', 'Enter'].includes(e.key)) return;
    const el = this;
    clearRipples(el);
    if (!allowGlobalRipple()) return;
    scheduleRipple(() => {
      const rect = getRect(el),
        x = rect.width / 2, y = rect.height / 2,
        radius = maximalExpandedCoverageRadius(x, y, rect.width, rect.height),
        haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER,
        baseDuration = BASE_DURATION,
        scaledDuration = Math.max(120, Math.round(baseDuration * INTERNAL_SPEED_MULTIPLIER * getExternalDurationMultiplier())),
        colorVal = getRippleColor(el),
        bg = getRippleBg(colorVal),
        ripple = getRippleNode(el);

      ripple.style.width = ripple.style.height = RIPPLE_HALO_START_DIAMETER + 'px';
      ripple.style.left = (rect.width / 2 - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      ripple.style.top = (rect.height / 2 - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      ripple.style.setProperty('--ripple-duration', scaledDuration + 'ms');
      ripple.style.setProperty('--ripple-blur', smartBlur());
      ripple.style.background = bg;
      ripple.style.setProperty('--ripple-final-scale', haloFinalScale);
      ripple.style.transform = 'scale(1) translate3d(0,0,0)';
      ripple.style.backfaceVisibility = 'hidden';
      el.appendChild(ripple);

      let set = activeRipples.get(el);
      if (!set) { set = new Set(); activeRipples.set(el, set); }
      set.add(ripple);

      requestAnimationFrame(() => {
        ripple.classList.add('animating');
        animateRipple(ripple, haloFinalScale);
      });
      setTimeout(() => {
        fadeOutAndRemoveRipple(ripple, 'auto', el);
        if (set && set.delete) set.delete(ripple);
      }, scaledDuration - 120);
      lastAllowed.set(el, now());
    });
  }

  // --- Observer / upgrade ---
  function observeDom() {
    if (observer) return;
    observer = new IntersectionObserver(entries => {
      for (let i = 0; i < entries.length; i++) {
        if (entries[i].isIntersecting) { upgradeElement(entries[i].target); }
      }
    }, { threshold: 0.01 });
    document.querySelectorAll('[wave]').forEach(el => observer.observe(el));
  }

  function upgradeElement(el) {
    if (upgradedElements.has(el)) return;
    el.classList.add(SURFACE_CLASS);
    upgradedElements.add(el);
    if (settings.disableTapHighlight) injectTapHighlightCSS();
  }
  function upgradeAll() {
    if (upgradeAllTimer) return;
    upgradeAllTimer = true;
    const runner = () => {
      const nodes = querySelectorAllCached('[wave]');
      for (let i = 0; i < nodes.length; i++) upgradeElement(nodes[i]);
      if (settings.disableTapHighlight) injectTapHighlightCSS();
      upgradeAllTimer = null;
    };
    if ('requestIdleCallback' in window) {
      requestIdleCallback(runner, { timeout: 130 });
    } else {
      setTimeout(runner, 12);
    }
  }

  // --- Global handlers install ---
  function globalPointerHandler(e) {
    if (e.button && e.button !== 0) return;
    let el = e.target.closest('[wave]');
    if (!el || !document.body.contains(el)) return;
    if (!upgradedElements.has(el)) upgradeElement(el);
    onPointerDown.call(el, e);
  }
  function globalKeyHandler(e) {
    let el = e.target.closest('[wave]');
    if (!el || !document.body.contains(el)) return;
    if (!upgradedElements.has(el)) upgradeElement(el);
    onKeyDown.call(el, e);
  }
  function installGlobalHandlers() {
    if (installGlobalHandlers.done) return;
    document.addEventListener('pointerdown', globalPointerHandler, { passive: true });
    document.addEventListener('keydown', globalKeyHandler, { passive: true, capture: true });
    installGlobalHandlers.done = true;
  }
  function installTouchGestureHandlers() {
    if (installTouchGestureHandlers.done) return;
    document.addEventListener('touchstart', onTouchStart, { passive: true });
    document.addEventListener('touchmove', onTouchMove, { passive: true });
    document.addEventListener('touchend', onTouchEnd, { passive: true });
    document.addEventListener('touchcancel', onTouchEnd, { passive: true });
    installTouchGestureHandlers.done = true;
  }

  // --- Init ---
  function initWakeEffect() {
    autoLoadWaveEffectCSS();
    autoLoadWaveSettingCSS();
    autoLoadWaveSettingJSON(function (opts) {
      if (opts && opts.disableTapHighlight) injectTapHighlightCSS();
      upgradeAll();
    });
    upgradeAll();
    observeDom();
    installGlobalHandlers();
    installTouchGestureHandlers();
    window.addEventListener('beforeunload', () => {
      lastGlobalRippleTime = 0;
    });
  }
  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initWakeEffect, { once: true });
    } else {
      initWakeEffect();
    }
  }

  // --- Developer API ---
  const config = {
    BASE_DURATION,
    MIN_DURATION,
    MAX_EXTRA,
    MIN_RIPPLE_INTERVAL,
    GLOBAL_MIN_RIPPLE_INTERVAL,
    GLOBAL_MAX_RIPPLES,
    RIPPLE_HALO_START_DIAMETER,
    COVERAGE_EXPAND_RATIO,
    get RIPPLE_FADE_DURATION_AUTO() { return RIPPLE_FADE_DURATION_AUTO; },
    get RIPPLE_FADE_DURATION_MANUAL() { return RIPPLE_FADE_DURATION_MANUAL; },
    setFadeDurationAuto(ms) { if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_AUTO = ms | 0; },
    setFadeDurationManual(ms) { if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_MANUAL = ms | 0; }
  };

  return {
    upgradeAll,
    upgradeElement,
    clearRipples,
    config,
    settings
  };
}));