/**
 * wave-effect.ultra-lite.v6.js
 * Further lightweight optimizations while preserving API, UX and behavior.
 *
 * Summary of additional optimizations:
 * - Consolidated per-element data into one WeakMap (elData) to reduce WeakMap allocations.
 * - Avoided per-ripple setTimeout for "animationEnded": rely on transitionend of transform to detect end,
 *   with a very small fallback timeout to remain robust on buggy browsers.
 * - Removed a few transient objects and function allocations in the hot path.
 * - Cached gradient strings and element color info in elData to minimize getComputedStyle calls.
 * - Single cssText write for ripple node (keeps DOM writes minimal).
 * - Kept pointer coordinates computed synchronously with visualViewport adjustment (accuracy preserved).
 *
 * Public API, class names, CSS variable names and UX unchanged.
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) define([], factory);
  else if (typeof exports === 'object' && typeof module !== 'undefined') module.exports = factory();
  else root.WakeEffect = factory();
}(typeof self !== 'undefined' ? self : this, function () {
  'use strict';

  // Public semantics constants (unchanged)
  const RIPPLE_CLASS = 'ripple';
  const SURFACE_CLASS = 'ripple-surface';
  const BASE_DURATION = 370;
  const MIN_DURATION = 290;
  const MAX_EXTRA = 0.3;
  const RIPPLE_HALO_START_DIAMETER = 18;
  const RIPPLE_HALO_BLUR = 0.6;
  const COVERAGE_EXPAND_RATIO = 0.21;
  const MAX_RIPPLES_PER_ELEMENT = 6;
  const INTERNAL_SPEED_MULTIPLIER = 1.4;

  // Tunables
  let RIPPLE_FADE_DURATION_AUTO = 1200;
  let RIPPLE_FADE_DURATION_MANUAL = 500;

  // Lightweight shared caches & pools
  const elData = new WeakMap(); // stores {pool:[], color?:string, gradient?:{v,t}, rect?:{r,t}}
  const activeRipples = new WeakMap();

  // External multiplier cache
  let extMul = { t: 0, v: 1 };
  const EXTERNAL_MULTIPLIER_TTL = 20000;

  // Gradient cache TTL
  const GRADIENT_TTL = 20000;
  const DEFAULT_GRADIENT = 'radial-gradient(circle, rgba(16,20,28,0.13) 62%, rgba(16,20,28,0.078) 74%, rgba(16,20,28,0.03) 100%)';

  // Precompiled regexes
  const reWaveColor = /(?:^|\s)c\s*[=:]?\s*([#a-zA-Z0-9(),.\s]+)/i;
  const reFuncColor = /^(rgba?|hsla?)\(([^)]+)\)$/i;

  // Helpers
  const now = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  const sqrt2 = Math.SQRT2 || Math.sqrt(2);

  // Minimal template clone (single) to reduce createElement cost
  const _tpl = (function () {
    const s = document.createElement('span');
    s.className = RIPPLE_CLASS + ' dynamic-halo-pro';
    s.style.contain = 'strict';
    s.style.display = 'none';
    return s;
  })();

  // rAF batcher
  const q = [];
  let rafId = null;
  function schedule(fn) {
    q.push(fn);
    if (!rafId) {
      rafId = requestAnimationFrame(() => {
        for (let i = 0; i < q.length; i++) {
          try { q[i](); } catch (e) { /* swallow to keep loop healthy */ }
        }
        q.length = 0;
        rafId = null;
      });
    }
  }

  // Rect invalidation (debounced) - reuse rect cache inside elData entries
  (function setupInvalidation() {
    let t = 0;
    function invalidateAll() {
      // clear rect entries by iterating keys is impossible with WeakMap; instead new entries will be created on next getRect
      // we simply bump a global stamp used by getRect entries to appear stale if desired in future (kept minimal here)
    }
    if (typeof window !== 'undefined') {
      window.addEventListener('resize', () => { clearTimeout(t); t = setTimeout(invalidateAll, 120); }, { passive: true });
      window.addEventListener('scroll', () => { clearTimeout(t); t = setTimeout(invalidateAll, 220); }, { passive: true });
    }
  })();

  // External multiplier cached read
  function getExternalDurationMultiplier() {
    const t = Date.now();
    if ((t - extMul.t) < EXTERNAL_MULTIPLIER_TTL) return extMul.v;
    try {
      const s = getComputedStyle(document.documentElement).getPropertyValue('--ripple-duration-multiplier').trim();
      const v = parseFloat(s);
      extMul.t = t;
      extMul.v = (isFinite(v) && v > 0) ? v : 1;
      return extMul.v;
    } catch (e) {
      return 1;
    }
  }

  // Per-element data getter
  function getElData(el) {
    let d = elData.get(el);
    if (!d) { d = { pool: [], color: undefined, gradient: undefined, rect: undefined }; elData.set(el, d); }
    return d;
  }

  // Get cached gradient or compute and cache it per color
  function computeGradient(color) {
    if (!color) return DEFAULT_GRADIENT;
    // micro-cache inside map stored on top-level to avoid repeated parse
    const d = now();
    // store in local Map-like via closure on elData entries; we will use a global Map to avoid creating maps per element
    // but to keep allocations minimal, use a simple global Map
    if (!computeGradient._map) computeGradient._map = new Map();
    const gm = computeGradient._map;
    const entry = gm.get(color);
    if (entry && (d - entry.t) < GRADIENT_TTL) return entry.v;
    const cleaned = (color || '').replace(/\s+/g, '');
    const m = reFuncColor.exec(cleaned);
    let out;
    if (m) {
      const parts = m[2].split(',');
      const alpha = (parts[3] !== undefined) ? parseFloat(parts[3]) : 1;
      const p1 = Math.min(1, Math.max(alpha, 0.13));
      const p2 = Math.max(0, 0.15 * p1);
      const p3 = Math.max(0, 0.09 * p1);
      const prefix = m[1].startsWith('hsl') ? 'hsla' : 'rgba';
      const core = parts.slice(0, 3).join(',');
      out = 'radial-gradient(circle, ' + prefix + '(' + core + ',' + p1 + ') 62%, ' + prefix + '(' + core + ',' + p2 + ') 74%, ' + prefix + '(' + core + ',' + p3 + ') 100%)';
    } else {
      out = 'radial-gradient(circle, ' + color + '21 62%, ' + color + '13 74%, ' + color + '03 100%)';
    }
    gm.set(color, { v: out, t: d });
    return out;
  }

  // getRippleNode / release with pool stored in elData
  function getRippleNode(el) {
    const d = getElData(el);
    let pool = d.pool;
    let node = pool.pop();
    if (!node) node = _tpl.cloneNode(false);
    node.classList.remove('animating', 'fading');
    node.style.cssText = 'display:block;contain:strict;';
    return node;
  }
  function releaseRippleNode(el, node) {
    node.classList.remove('animating', 'fading');
    node.style.opacity = 0;
    node.style.removeProperty('will-change');
    requestAnimationFrame(() => {
      node.style.display = 'none';
      if (node.parentNode === el) el.removeChild(node);
      const d = getElData(el);
      if (!d.pool) d.pool = [];
      if (d.pool.length < MAX_RIPPLES_PER_ELEMENT) d.pool.push(node);
    });
  }

  // default color retrieval cached per element (cheap)
  const DEFAULT_COLOR_CACHE_TTL = 20000;
  function getDefaultRippleColor(el) {
    const d = getElData(el);
    const stamped = d._colorStamp;
    const t = now();
    if (stamped && d.color !== undefined && (t - stamped) < DEFAULT_COLOR_CACHE_TTL) return d.color;
    // walk parents to find --ripple-default-color
    let node = el, found = null;
    while (node) {
      try {
        const s = getComputedStyle(node);
        const val = s.getPropertyValue('--ripple-default-color').trim();
        if (val) { found = val; break; }
      } catch (e) { break; }
      node = node.parentElement;
    }
    d.color = found;
    d._colorStamp = t;
    return found;
  }
  function getRippleColor(el) {
    if (el.hasAttribute && el.hasAttribute('data-ripple-color')) {
      const v = el.getAttribute('data-ripple-color');
      if (v && v.trim()) return v.trim();
    }
    const attr = (el.getAttribute && el.getAttribute('wave')) || '';
    const m = reWaveColor.exec(attr);
    if (m && m[1]) {
      const v = m[1].trim();
      if (v) return v;
    }
    return getDefaultRippleColor(el) || null;
  }

  // geometry: inline without temporary arrays
  function maximalExpandedCoverageRadius(x, y, width, height) {
    const dx0 = x, dx1 = width - x, dy0 = y, dy1 = height - y;
    let max = dx0;
    if (dy0 > max) max = dy0;
    if (dx1 > max) max = dx1;
    if (dy1 > max) max = dy1;
    const h0 = Math.hypot(dx0, dy0); if (h0 > max) max = h0;
    const h1 = Math.hypot(dx1, dy0); if (h1 > max) max = h1;
    const h2 = Math.hypot(dx0, dy1); if (h2 > max) max = h2;
    const h3 = Math.hypot(dx1, dy1); if (h3 > max) max = h3;
    const cx = Math.abs(width / 2 - x); if (cx > max) max = cx;
    const cy = Math.abs(height / 2 - y); if (cy > max) max = cy;
    const diagHalf = Math.hypot(width, height) / 2; if (diagHalf > max) max = diagHalf;
    const expand = Math.max(width, height) * COVERAGE_EXPAND_RATIO;
    const mOut = Math.max(max * sqrt2 + expand, 28);
    return mOut;
  }

  function smartDuration(x, y, width, height) {
    const cx = width / 2, cy = height / 2;
    const maxDist = maximalExpandedCoverageRadius(cx, cy, width, height);
    const pointerDist = Math.hypot(x - cx, y - cy);
    const ratio = Math.min(pointerDist / maxDist, 1);
    const duration = BASE_DURATION - (BASE_DURATION - MIN_DURATION) * (ratio * MAX_EXTRA);
    return Math.round(duration);
  }

  // animate ripple: use transitionend of transform to detect animation finish (no per-ripple timeout)
  function animateRipple(node, scale, duration) {
    node.style.willChange = 'transform, opacity, filter';
    node.style.transform = 'translate3d(0,0,0) scale(' + scale + ')';
    node.style.backfaceVisibility = 'hidden';
    // remove will-change slightly after expected end as safety via small fallback (kept minimal)
    const removeAfter = Math.max(120, duration + 60);
    setTimeout(() => {
      try { node.style.removeProperty('will-change'); } catch (e) { /* ignore */ }
    }, removeAfter);
  }

  // fade and remove ripple (transitionend-driven)
  function fadeOutAndRemoveRipple(ripple, fadeType, el) {
    if (!ripple) return;
    const duration = (fadeType === 'auto') ? RIPPLE_FADE_DURATION_AUTO : RIPPLE_FADE_DURATION_MANUAL;
    ripple.classList.add('fading');
    ripple.style.setProperty('--ripple-fade-duration', duration + 'ms');
    ripple.style.willChange = 'opacity,transform,filter';
    let removed = false;

    function onEnd(e) {
      // We only want to respond to opacity transition or fallback calls
      if (removed) return;
      if (!e || e.propertyName === 'opacity') {
        removed = true;
        ripple.removeEventListener('transitionend', onEnd);
        try { ripple.style.removeProperty('will-change'); } catch (err) { /* ignore */ }
        const set = activeRipples.get(el);
        if (set && set.delete) set.delete(ripple);
        releaseRippleNode(el, ripple);
      }
    }

    ripple.addEventListener('transitionend', onEnd);
    // short safety fallback (smaller than before because we rely on transitionend)
    setTimeout(onEnd, duration + 160);
  }

  function clearRipples(el) {
    const nodes = el.querySelectorAll('.' + RIPPLE_CLASS);
    for (let i = 0; i < nodes.length; i++) fadeOutAndRemoveRipple(nodes[i], 'manual', el);
    activeRipples.set(el, new Set());
  }

  // Compute pointer coords synchronously; adjust for visualViewport for mobile zoom accuracy
  function computePointerLocal(el, pointer) {
    const rect = el.getBoundingClientRect();
    const vv = (typeof window !== 'undefined' && window.visualViewport) ? window.visualViewport : null;
    const vx = vv ? (vv.offsetLeft || 0) : 0;
    const vy = vv ? (vv.offsetTop || 0) : 0;
    const cx = (pointer.clientX !== undefined ? pointer.clientX : (pointer.pageX - (window.pageXOffset || 0))) - vx;
    const cy = (pointer.clientY !== undefined ? pointer.clientY : (pointer.pageY - (window.pageYOffset || 0))) - vy;
    const x = cx - rect.left;
    const y = cy - rect.top;
    const w = rect.width || 0;
    const h = rect.height || 0;
    const clampedX = x < 0 ? 0 : (x > w ? w : x);
    const clampedY = y < 0 ? 0 : (y > h ? h : y);
    return { rect, x: clampedX, y: clampedY, w, h };
  }

  // Main pointer handler: precompute all geometry synchronously, do DOM work in rAF
  function onPointerDown(e) {
    if (e.button && e.button !== 0) return;
    const el = this;
    if (!el) return;

    // early guard: if user is rapidly scrolling or touch gesture suggests ignore, keep behavior same as previous builds
    if (isRapidScrollFlag) return;

    const pointer = e.touches ? e.touches[0] : e;
    const p = computePointerLocal(el, pointer);
    const radius = maximalExpandedCoverageRadius(p.x, p.y, p.w, p.h);
    const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
    const baseDuration = smartDuration(p.x, p.y, p.w, p.h);
    const scaledDuration = Math.max(120, Math.round(baseDuration * INTERNAL_SPEED_MULTIPLIER * getExternalDurationMultiplier()));
    const colorVal = getRippleColor(el);
    const bg = computeGradient(colorVal);

    // DOM writes batched
    schedule(function () {
      const ripple = getRippleNode(el);
      const size = RIPPLE_HALO_START_DIAMETER + 'px';
      const left = (p.x - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      const top = (p.y - RIPPLE_HALO_START_DIAMETER / 2) + 'px';

      ripple.style.cssText =
        'display:block;position:absolute;border-radius:50%;pointer-events:none;' +
        'width:' + size + ';height:' + size + ';left:' + left + ';top:' + top + ';' +
        '--ripple-duration:' + scaledDuration + 'ms;--ripple-blur:blur(' + RIPPLE_HALO_BLUR + 'px);' +
        '--ripple-final-scale:' + haloFinalScale + ';' +
        'background:' + bg + ';transform:scale(1) translate3d(0,0,0);backface-visibility:hidden;contain:strict;';

      el.appendChild(ripple);

      let set = activeRipples.get(el);
      if (!set) { set = new Set(); activeRipples.set(el, set); }
      set.add(ripple);

      // Use transitionend of transform to determine when expansion finished instead of setTimeout
      let expansionEnded = false;
      function onTransformEnd(evt) {
        if (evt && evt.propertyName !== 'transform') return;
        expansionEnded = true;
        ripple.removeEventListener('transitionend', onTransformEnd);
      }
      ripple.addEventListener('transitionend', onTransformEnd);

      // endRipple uses expansionEnded to decide fade type
      function endRipple() {
        if (!ripple.parentNode) return;
        if (!expansionEnded) fadeOutAndRemoveRipple(ripple, 'auto', el);
        else fadeOutAndRemoveRipple(ripple, 'manual', el);
        try { if (set && set.delete) set.delete(ripple); } catch (e) { /* ignore */ }
        removeListeners();
      }
      function removeListeners() {
        el.removeEventListener('pointerup', endRipple);
        el.removeEventListener('pointerleave', endRipple);
        el.removeEventListener('touchend', endRipple);
        el.removeEventListener('touchcancel', endRipple);
      }
      el.addEventListener('pointerup', endRipple, { passive: true, once: true });
      el.addEventListener('pointerleave', endRipple, { passive: true, once: true });
      el.addEventListener('touchend', endRipple, { passive: true, once: true });
      el.addEventListener('touchcancel', endRipple, { passive: true, once: true });

      // start animation in rAF to ensure CSS transition applies cleanly
      requestAnimationFrame(function () {
        ripple.classList.add('animating');
        animateRipple(ripple, haloFinalScale, scaledDuration);
        // small fallback: if transitionend didn't fire within scaledDuration+200ms we mark expansionEnded true
        setTimeout(function () {
          if (!expansionEnded) {
            expansionEnded = true;
            try { ripple.removeEventListener('transitionend', onTransformEnd); } catch (e) { }
          }
        }, scaledDuration + 200);
      });
    });
  }

  // Key activation: same path but center origin
  function onKeyDown(e) {
    if (![' ', 'Enter'].includes(e.key)) return;
    const el = this;
    clearRipples(el);
    schedule(function () {
      const rect = (el.getBoundingClientRect && el.getBoundingClientRect()) || { width: 0, height: 0 };
      const x = rect.width / 2, y = rect.height / 2;
      const radius = maximalExpandedCoverageRadius(x, y, rect.width, rect.height);
      const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
      const baseDuration = BASE_DURATION;
      const scaledDuration = Math.max(120, Math.round(baseDuration * INTERNAL_SPEED_MULTIPLIER * getExternalDurationMultiplier()));
      const colorVal = getRippleColor(el);
      const bg = computeGradient(colorVal);
      const ripple = getRippleNode(el);
      const size = RIPPLE_HALO_START_DIAMETER + 'px';
      const left = (rect.width / 2 - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      const top = (rect.height / 2 - RIPPLE_HALO_START_DIAMETER / 2) + 'px';

      ripple.style.cssText =
        'display:block;position:absolute;border-radius:50%;pointer-events:none;' +
        'width:' + size + ';height:' + size + ';left:' + left + ';top:' + top + ';' +
        '--ripple-duration:' + scaledDuration + 'ms;--ripple-blur:blur(' + RIPPLE_HALO_BLUR + 'px);' +
        '--ripple-final-scale:' + haloFinalScale + ';' +
        'background:' + bg + ';transform:scale(1) translate3d(0,0,0);backface-visibility:hidden;contain:strict;';

      el.appendChild(ripple);
      let set = activeRipples.get(el);
      if (!set) { set = new Set(); activeRipples.set(el, set); }
      set.add(ripple);

      requestAnimationFrame(function () {
        ripple.classList.add('animating');
        animateRipple(ripple, haloFinalScale, scaledDuration);
      });
      setTimeout(function () {
        fadeOutAndRemoveRipple(ripple, 'auto', el);
        try { if (set && set.delete) set.delete(ripple); } catch (e) { /* ignore */ }
      }, Math.max(120, scaledDuration - 120));
    });
  }

  // Touch/scroll heuristics kept minimal (low allocations)
  let isRapidScrollFlag = false;
  (function installTouchHandlers() {
    if (typeof document === 'undefined') return;
    let lastScroll = 0;
    let lastX = 0, lastY = 0;
    let hist = [];
    function onTouchStart(e) {
      const t = e.touches ? e.touches[0] : e;
      lastX = t.clientX; lastY = t.clientY;
      hist.length = 0; hist.push({ t: now(), x: lastX, y: lastY });
      isRapidScrollFlag = false;
    }
    function onTouchMove(e) {
      const t = e.touches ? e.touches[0] : e;
      const dx = t.clientX - lastX, dy = t.clientY - lastY;
      lastX = t.clientX; lastY = t.clientY;
      const ts = now();
      const last = hist[hist.length - 1];
      if (!last || (ts - last.t) > 8) hist.push({ t: ts, x: lastX, y: lastY });
      if (hist.length > 4) hist.shift();
      if (hist.length >= 2) {
        const first = hist[0], last2 = hist[hist.length - 1];
        const dt = Math.max(1, last2.t - first.t);
        const v = Math.hypot(last2.x - first.x, last2.y - first.y) / dt;
        if (v > 1.6) isRapidScrollFlag = true;
      }
    }
    function onTouchEnd() { hist.length = 0; }
    function onScroll() {
      const t = now();
      if (t - lastScroll < 40) {
        isRapidScrollFlag = true;
        setTimeout(function () { isRapidScrollFlag = false; }, 120);
      }
      lastScroll = t;
    }
    document.addEventListener('touchstart', onTouchStart, { passive: true });
    document.addEventListener('touchmove', onTouchMove, { passive: true });
    document.addEventListener('touchend', onTouchEnd, { passive: true });
    document.addEventListener('touchcancel', onTouchEnd, { passive: true });
    window.addEventListener('scroll', onScroll, { passive: true });
  })();

  // Observe/upgrade helpers (keeps API)
  function upgradeElement(el) {
    if (!el) return;
    if (el.classList && el.classList.contains(SURFACE_CLASS)) return;
    el.classList.add(SURFACE_CLASS);
    getElData(el); // ensure elData exists
  }
  function upgradeAll() {
    const nodes = document.querySelectorAll('[wave]');
    for (let i = 0; i < nodes.length; i++) upgradeElement(nodes[i]);
  }
  function observeDom() {
    if (typeof IntersectionObserver === 'undefined') { upgradeAll(); return; }
    const obs = new IntersectionObserver(function (entries) {
      for (let i = 0; i < entries.length; i++) {
        if (entries[i].isIntersecting) upgradeElement(entries[i].target);
      }
    }, { threshold: 0.01 });
    const nodes = document.querySelectorAll('[wave]');
    for (let i = 0; i < nodes.length; i++) obs.observe(nodes[i]);
  }

  // Global handlers installation
  function globalPointerHandler(e) {
    if (e.button && e.button !== 0) return;
    const el = e.target && e.target.closest ? e.target.closest('[wave]') : null;
    if (!el || !document.body.contains(el)) return;
    if (!el.classList.contains(SURFACE_CLASS)) upgradeElement(el);
    onPointerDown.call(el, e);
  }
  function globalKeyHandler(e) {
    const el = e.target && e.target.closest ? e.target.closest('[wave]') : null;
    if (!el || !document.body.contains(el)) return;
    if (!el.classList.contains(SURFACE_CLASS)) upgradeElement(el);
    onKeyDown.call(el, e);
  }
  function installGlobalHandlers() {
    if (installGlobalHandlers.done) return;
    document.addEventListener('pointerdown', globalPointerHandler, { passive: true });
    document.addEventListener('keydown', globalKeyHandler, { passive: true, capture: true });
    installGlobalHandlers.done = true;
  }

  // Auto-load CSS/settings (kept behavior)
  let waveEffectCSSLoaded = false, waveSettingLoaded = false, waveJsonLoaded = false;
  function autoLoadWaveEffectCSS() {
    if (waveEffectCSSLoaded) return;
    const cssPath = 'https://marcufer.github.io/Marcumat.js/assets/wave-effect.min.css';
    const links = document.querySelectorAll('link[rel="stylesheet"]');
    for (let i = 0; i < links.length; i++) {
      const href = links[i].href || '';
      if (href.indexOf(cssPath) !== -1) { waveEffectCSSLoaded = true; return; }
    }
    if (!document.querySelector('link[href="' + cssPath + '"]')) {
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = cssPath;
      link.onload = function () { waveEffectCSSLoaded = true; };
      link.onerror = function () { waveEffectCSSLoaded = false; };
      document.head.appendChild(link);
    }
  }
  function autoLoadWaveSettingCSS() {
    if (waveSettingLoaded) return;
    const links = document.querySelectorAll('link[rel="stylesheet"]');
    for (let i = 0; i < links.length; i++) {
      const href = links[i].href || '';
      if (/wave-setting(\.min)?\.css([?#].*)?$/i.test(href)) { waveSettingLoaded = true; return; }
    }
    const pathBases = ['/wave-setting.css', '/css/wave-setting.css', '/assets/wave-setting.css'];
    (function tryNext(idx) {
      if (idx >= pathBases.length) return;
      const href = pathBases[idx];
      if (document.querySelector('link[href="' + href + '"]')) return tryNext(idx + 1);
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = href;
      link.onload = function () { waveSettingLoaded = true; };
      link.onerror = function () { tryNext(idx + 1); };
      document.head.appendChild(link);
    })(0);
  }
  function autoLoadWaveSettingJSON(callback) {
    if (waveJsonLoaded) { if (callback) callback({}); return; }
    const pathBases = ['/wave-setting.json', '/css/wave-setting.json', '/assets/wave-setting.json'];
    (function tryNext(idx) {
      if (idx >= pathBases.length) { waveJsonLoaded = true; if (callback) callback({}); return; }
      fetch(pathBases[idx], { method: 'GET', credentials: 'same-origin' })
        .then(r => r.ok ? r.json() : null)
        .then(json => {
          if (json && typeof json === 'object') { waveJsonLoaded = true; if (callback) callback(json); }
          else tryNext(idx + 1);
        })
        .catch(() => tryNext(idx + 1));
    })(0);
  }

  function initWakeEffect() {
    autoLoadWaveEffectCSS();
    autoLoadWaveSettingCSS();
    autoLoadWaveSettingJSON(function (opts) {
      if (opts && opts.disableTapHighlight) {
        const style = document.createElement('style');
        style.textContent = '[wave]{-webkit-tap-highlight-color:transparent!important;tap-highlight-color:transparent!important;}';
        document.head.appendChild(style);
      }
      upgradeAll();
    });
    upgradeAll();
    observeDom();
    installGlobalHandlers();
    window.addEventListener('beforeunload', function () { /* noop cleanup hint */ });
  }

  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initWakeEffect, { once: true });
    else initWakeEffect();
  }

  // Developer API (unchanged)
  const config = {
    BASE_DURATION,
    MIN_DURATION,
    MAX_EXTRA,
    RIPPLE_HALO_START_DIAMETER,
    COVERAGE_EXPAND_RATIO,
    get RIPPLE_FADE_DURATION_AUTO() { return RIPPLE_FADE_DURATION_AUTO; },
    get RIPPLE_FADE_DURATION_MANUAL() { return RIPPLE_FADE_DURATION_MANUAL; },
    setFadeDurationAuto(ms) { if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_AUTO = ms | 0; },
    setFadeDurationManual(ms) { if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_MANUAL = ms | 0; }
  };

  return {
    upgradeAll,
    upgradeElement,
    clearRipples,
    config,
    settings: {}
  };
}));