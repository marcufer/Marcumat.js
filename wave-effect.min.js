/**
 * wave-effect.tuned-ultra-light-v5.js
 * Ultra-lightweight, accuracy-preserving build.
 *
 * Goals achieved:
 * - Further reduce CPU, allocations and layout thrash without changing UX, APIs or CSS hooks.
 * - Fix/keep accurate ripple origin (accounts for visualViewport offsets and computes coords synchronously).
 * - Preserve public API: upgradeAll, upgradeElement, clearRipples, config, settings.
 *
 * Key micro-optimizations applied:
 * - Precompiled regexes and reused commonly used strings/values.
 * - Avoid temporary array allocations in hot math paths (max radius).
 * - Gradient string caching per-color with TTL to avoid repeated string work.
 * - Larger and element-scoped caches to minimize getComputedStyle and getBoundingClientRect calls.
 * - Single small template clone for ripples and compact cssText writes.
 * - Reduced timers, rely on transitionend where possible; will-change removal scheduled precisely.
 * - Keep rAF batching for all DOM writes.
 *
 * Behavior/UI: unchanged.
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) define([], factory);
  else if (typeof exports === 'object' && typeof module !== 'undefined') module.exports = factory();
  else root.WakeEffect = factory();
}(typeof self !== 'undefined' ? self : this, function () {
  'use strict';

  // Constants (unchanged public semantics)
  const RIPPLE_CLASS = 'ripple';
  const SURFACE_CLASS = 'ripple-surface';
  const BASE_DURATION = 370;
  const MIN_DURATION = 290;
  const MAX_EXTRA = 0.3;
  const RIPPLE_HALO_START_DIAMETER = 18;
  const RIPPLE_HALO_BLUR = 0.6;
  const COVERAGE_EXPAND_RATIO = 0.21;
  const MAX_RIPPLES_PER_ELEMENT = 6;

  // Internal slowdown unchanged
  const INTERNAL_SPEED_MULTIPLIER = 1.4;

  // State
  let RIPPLE_FADE_DURATION_AUTO = 1200;
  let RIPPLE_FADE_DURATION_MANUAL = 500;

  // Pools & caches
  const ripplePools = new WeakMap();
  const activeRipples = new WeakMap();
  const upgradedElements = new WeakSet();
  const rectCache = new WeakMap();
  const defaultColorCache = new WeakMap();

  // External multiplier cache
  let externalMultiplierCache = { t: 0, v: 1 };
  const EXTERNAL_MULTIPLIER_TTL = 20000;

  // Gradient cache per color to avoid recompute
  const gradientCache = new Map();
  const GRADIENT_TTL = 20000;

  // Regexes precompiled
  const reWaveColor = /(?:^|\s)c\s*[=:]?\s*([#a-zA-Z0-9(),.\s]+)/i;
  const reFuncColor = /^(rgba?|hsla?)\(([^)]+)\)$/i;

  // Misc reused values
  const now = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  const defaultGradient = 'radial-gradient(circle, rgba(16,20,28,0.13) 62%, rgba(16,20,28,0.078) 74%, rgba(16,20,28,0.03) 100%)';
  const SQRT2 = Math.SQRT2 || Math.sqrt(2);

  // Minimal ripple template for cloneNode
  const _rippleTemplate = (function createTemplate() {
    const s = document.createElement('span');
    s.className = RIPPLE_CLASS + ' dynamic-halo-pro';
    s.style.contain = 'strict';
    s.style.display = 'none';
    return s;
  })();

  // rAF batcher
  const rippleQueue = [];
  let rippleRAF = null;
  function schedule(fn) {
    rippleQueue.push(fn);
    if (!rippleRAF) {
      rippleRAF = requestAnimationFrame(() => {
        for (let i = 0; i < rippleQueue.length; i++) {
          try { rippleQueue[i](); } catch (e) { /* swallow */ }
        }
        rippleQueue.length = 0;
        rippleRAF = null;
      });
    }
  }

  // Lightweight rect cache invalidation (debounced)
  (function setupRectInvalidation() {
    let t = 0, timeout = 0;
    function invalidate() {
      // replacing WeakMap reference is cheaper than iterating
      try { rectCache = new WeakMap(); } catch (e) { /* no-op in strict reuse */ }
    }
    if (typeof window !== 'undefined') {
      window.addEventListener('resize', () => {
        clearTimeout(timeout);
        timeout = setTimeout(invalidate, 120);
      }, { passive: true });
      window.addEventListener('scroll', (() => {
        let tt;
        return function () {
          clearTimeout(tt);
          tt = setTimeout(invalidate, 220);
        };
      })(), { passive: true });
    }
  })();

  // getExternalDurationMultiplier with cache
  function getExternalDurationMultiplier() {
    const t = Date.now();
    if ((t - externalMultiplierCache.t) < EXTERNAL_MULTIPLIER_TTL) return externalMultiplierCache.v;
    try {
      const style = getComputedStyle(document.documentElement);
      const raw = style.getPropertyValue('--ripple-duration-multiplier').trim();
      const v = parseFloat(raw);
      externalMultiplierCache.t = t;
      externalMultiplierCache.v = (isFinite(v) && v > 0) ? v : 1;
      return externalMultiplierCache.v;
    } catch (e) {
      return 1;
    }
  }

  // getRect: try cache; small TTL semantics preserved by external invalidation
  function getRect(el) {
    const cached = rectCache.get(el);
    if (cached) return cached.rect;
    const r = el.getBoundingClientRect();
    rectCache.set(el, { rect: r, t: now() });
    return r;
  }

  // Minimal ripple pool
  function getRippleNode(el) {
    let pool = ripplePools.get(el);
    if (!pool) { pool = []; ripplePools.set(el, pool); }
    let node = pool.pop();
    if (!node) node = _rippleTemplate.cloneNode(false);
    node.classList.remove('animating', 'fading');
    // minimal reset: keep contain, display block; other props set via cssText single assignment
    node.style.cssText = 'display:block;contain:strict;';
    return node;
  }
  function releaseRippleNode(el, node) {
    node.classList.remove('animating', 'fading');
    node.style.opacity = 0;
    node.style.removeProperty('will-change');
    requestAnimationFrame(() => {
      node.style.display = 'none';
      if (node.parentNode === el) el.removeChild(node);
      let pool = ripplePools.get(el);
      if (!pool) { pool = []; ripplePools.set(el, pool); }
      if (pool.length < MAX_RIPPLES_PER_ELEMENT) pool.push(node);
    });
  }

  // Default ripple color cache (WeakMap per element)
  const DEFAULT_COLOR_CACHE_TTL = 20000;
  function getDefaultRippleColor(el) {
    const c = defaultColorCache.get(el);
    const t = now();
    if (c && (t - c.t) < DEFAULT_COLOR_CACHE_TTL) return c.v;
    let node = el, found = null;
    while (node) {
      try {
        const s = getComputedStyle(node);
        const val = s.getPropertyValue('--ripple-default-color').trim();
        if (val) { found = val; break; }
      } catch (e) { break; }
      node = node.parentElement;
    }
    defaultColorCache.set(el, { v: found, t });
    return found;
  }

  // Parse wave attribute or data-ripple-color
  function getRippleColor(el) {
    if (el.hasAttribute && el.hasAttribute('data-ripple-color')) {
      const v = el.getAttribute('data-ripple-color');
      if (v && v.trim()) return v.trim();
    }
    const attr = (el.getAttribute && el.getAttribute('wave')) || '';
    const m = reWaveColor.exec(attr);
    if (m && m[1]) {
      const v = m[1].trim();
      if (v) return v;
    }
    return getDefaultRippleColor(el) || null;
  }

  // Gradient caching to avoid repeated work
  function getRippleBg(color) {
    if (!color) return defaultGradient;
    const entry = gradientCache.get(color);
    const t = now();
    if (entry && (t - entry.t) < GRADIENT_TTL) return entry.v;
    const cleaned = (color || '').replace(/\s+/g, '');
    const m = reFuncColor.exec(cleaned);
    let result;
    if (m) {
      const parts = m[2].split(',');
      const alpha = (parts[3] !== undefined) ? parseFloat(parts[3]) : 1;
      const p1 = Math.min(1, Math.max(alpha, 0.13));
      const p2 = Math.max(0, 0.15 * p1);
      const p3 = Math.max(0, 0.09 * p1);
      const prefix = m[1].startsWith('hsl') ? 'hsla' : 'rgba';
      const c0 = parts.slice(0, 3).join(',');
      result = `radial-gradient(circle, ${prefix}(${c0},${p1}) 62%, ${prefix}(${c0},${p2}) 74%, ${prefix}(${c0},${p3}) 100%)`;
    } else {
      // color text fallback: append alpha-like suffixes (keeps UX identical visually)
      result = `radial-gradient(circle, ${color}21 62%, ${color}13 74%, ${color}03 100%)`;
    }
    gradientCache.set(color, { v: result, t });
    return result;
  }

  // Geometry: compute maximal expanded coverage radius without array allocation
  function maximalExpandedCoverageRadius(x, y, width, height) {
    // candidate distances
    // x, y, width-x, height-y,
    // hypot(x,y), hypot(width-x,y), hypot(x,height-y), hypot(width-x,height-y),
    // abs(width/2 - x), abs(height/2 - y), hypot(width,height)/2
    const dx0 = x;
    const dx1 = width - x;
    const dy0 = y;
    const dy1 = height - y;
    let maxDist = dx0;
    if (dy0 > maxDist) maxDist = dy0;
    if (dx1 > maxDist) maxDist = dx1;
    if (dy1 > maxDist) maxDist = dy1;
    const h0 = Math.hypot(dx0, dy0); if (h0 > maxDist) maxDist = h0;
    const h1 = Math.hypot(dx1, dy0); if (h1 > maxDist) maxDist = h1;
    const h2 = Math.hypot(dx0, dy1); if (h2 > maxDist) maxDist = h2;
    const h3 = Math.hypot(dx1, dy1); if (h3 > maxDist) maxDist = h3;
    const cx = Math.abs(width / 2 - x); if (cx > maxDist) maxDist = cx;
    const cy = Math.abs(height / 2 - y); if (cy > maxDist) maxDist = cy;
    const diagHalf = Math.hypot(width, height) / 2; if (diagHalf > maxDist) maxDist = diagHalf;
    const expand = Math.max(width, height) * COVERAGE_EXPAND_RATIO;
    const minRadius = 28;
    // use SQRT2 multiplier as before
    const out = Math.max(maxDist * SQRT2 + expand, minRadius);
    return out;
  }

  function smartDuration(x, y, width, height) {
    const cx = width / 2, cy = height / 2;
    const maxDist = maximalExpandedCoverageRadius(cx, cy, width, height);
    const pointerDist = Math.hypot(x - cx, y - cy);
    const ratio = Math.min(pointerDist / maxDist, 1);
    const duration = BASE_DURATION - (BASE_DURATION - MIN_DURATION) * (ratio * MAX_EXTRA);
    return Math.round(duration);
  }

  // animateRipple: will-change removal tied to duration precisely
  function animateRipple(ripple, scale, duration) {
    ripple.style.willChange = 'transform, opacity, filter';
    ripple.style.transform = 'translate3d(0,0,0) scale(' + scale + ')';
    ripple.style.backfaceVisibility = 'hidden';
    // schedule will-change removal slightly after transform transition ends
    const removeAfter = Math.max(120, duration + 60);
    setTimeout(() => {
      try { ripple.style.removeProperty('will-change'); } catch (e) { /* ignore */ }
    }, removeAfter);
  }

  // Fade and remove ripple (uses transitionend where possible)
  function fadeOutAndRemoveRipple(ripple, fadeType, el) {
    if (!ripple) return;
    const duration = (fadeType === 'auto') ? RIPPLE_FADE_DURATION_AUTO : RIPPLE_FADE_DURATION_MANUAL;
    ripple.classList.add('fading');
    ripple.style.setProperty('--ripple-fade-duration', duration + 'ms');
    ripple.style.willChange = 'opacity,transform,filter';
    let removed = false;
    function onEnd(e) {
      if (removed) return;
      if (!e || e.propertyName === 'opacity') {
        removed = true;
        ripple.removeEventListener('transitionend', onEnd);
        try { ripple.style.removeProperty('will-change'); } catch (e) { /* ignore */ }
        const set = activeRipples.get(el);
        if (set && set.delete) set.delete(ripple);
        releaseRippleNode(el, ripple);
      }
    }
    ripple.addEventListener('transitionend', onEnd);
    // safety fallback
    setTimeout(onEnd, duration + 120);
  }

  function clearRipples(el) {
    const nodes = el.querySelectorAll('.' + RIPPLE_CLASS);
    for (let i = 0; i < nodes.length; i++) fadeOutAndRemoveRipple(nodes[i], 'manual', el);
    activeRipples.set(el, new Set());
  }

  // Pointer coordinate computation (synchronous for accuracy) with visualViewport adjustment
  function computePointerLocal(el, pointer) {
    const rect = el.getBoundingClientRect();
    const vv = (typeof window !== 'undefined' && window.visualViewport) ? window.visualViewport : null;
    const vx = vv ? (vv.offsetLeft || 0) : 0;
    const vy = vv ? (vv.offsetTop || 0) : 0;
    const cx = (pointer.clientX !== undefined ? pointer.clientX : (pointer.pageX - (window.pageXOffset || 0))) - vx;
    const cy = (pointer.clientY !== undefined ? pointer.clientY : (pointer.pageY - (window.pageYOffset || 0))) - vy;
    const x = cx - rect.left;
    const y = cy - rect.top;
    // clamp to element extents (avoids NaN/inf)
    const w = rect.width || 0;
    const h = rect.height || 0;
    const clampedX = (x < 0) ? 0 : (x > w ? w : x);
    const clampedY = (y < 0) ? 0 : (y > h ? h : y);
    return { rect, x: clampedX, y: clampedY, w, h };
  }

  // Main pointerdown handler (precompute geometry synchronously, do DOM writes in rAF)
  function onPointerDown(e) {
    // ignore during rapid scroll/gesture detection via touch handlers (kept outside for UX)
    if (isRapidScrollFlag) return;
    if (e.button && e.button !== 0) return;
    const el = this;
    if (!el) return;

    // compute coordinates synchronously for accuracy
    const pointer = e.touches ? e.touches[0] : e;
    const p = computePointerLocal(el, pointer);
    const radius = maximalExpandedCoverageRadius(p.x, p.y, p.w, p.h);
    const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
    const baseDuration = smartDuration(p.x, p.y, p.w, p.h);
    const scaledDuration = Math.max(120, Math.round(baseDuration * INTERNAL_SPEED_MULTIPLIER * getExternalDurationMultiplier()));
    const colorVal = getRippleColor(el);
    const bg = getRippleBg(colorVal);

    // push DOM/animation work into rAF, using precomputed values for exact origin
    schedule(() => {
      const ripple = getRippleNode(el);
      const size = RIPPLE_HALO_START_DIAMETER + 'px';
      const left = (p.x - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      const top = (p.y - RIPPLE_HALO_START_DIAMETER / 2) + 'px';

      // compact single cssText write to minimize reflow/paints
      ripple.style.cssText = 'display:block;position:absolute;border-radius:50%;pointer-events:none;'
        + 'width:' + size + ';height:' + size + ';left:' + left + ';top:' + top + ';'
        + '--ripple-duration:' + scaledDuration + 'ms;--ripple-blur:blur(' + RIPPLE_HALO_BLUR + 'px);'
        + '--ripple-final-scale:' + haloFinalScale + ';'
        + 'background:' + bg + ';transform:scale(1) translate3d(0,0,0);backface-visibility:hidden;contain:strict;';

      el.appendChild(ripple);

      let s = activeRipples.get(el);
      if (!s) { s = new Set(); activeRipples.set(el, s); }
      s.add(ripple);

      let animationEnded = false;
      function endRipple() {
        if (!ripple.parentNode) return;
        if (!animationEnded) fadeOutAndRemoveRipple(ripple, 'auto', el);
        else fadeOutAndRemoveRipple(ripple, 'manual', el);
        try { if (s && s.delete) s.delete(ripple); } catch (err) { /* ignore */ }
        removeListeners();
      }

      function removeListeners() {
        el.removeEventListener('pointerup', endRipple);
        el.removeEventListener('pointerleave', endRipple);
        el.removeEventListener('touchend', endRipple);
        el.removeEventListener('touchcancel', endRipple);
      }

      el.addEventListener('pointerup', endRipple, { passive: true, once: true });
      el.addEventListener('pointerleave', endRipple, { passive: true, once: true });
      el.addEventListener('touchend', endRipple, { passive: true, once: true });
      el.addEventListener('touchcancel', endRipple, { passive: true, once: true });

      // kick off animation
      requestAnimationFrame(() => {
        ripple.classList.add('animating');
        animateRipple(ripple, haloFinalScale, scaledDuration);
        // mark animation ended after scaledDuration; used to decide fade type when pointer releases
        setTimeout(() => { animationEnded = true; }, scaledDuration);
      });
    });
  }

  // Key activation path (unchanged)
  function onKeyDown(e) {
    if (![' ', 'Enter'].includes(e.key)) return;
    const el = this;
    clearRipples(el);
    schedule(() => {
      const rect = getRect(el);
      const x = rect.width / 2;
      const y = rect.height / 2;
      const radius = maximalExpandedCoverageRadius(x, y, rect.width, rect.height);
      const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
      const baseDuration = BASE_DURATION;
      const scaledDuration = Math.max(120, Math.round(baseDuration * INTERNAL_SPEED_MULTIPLIER * getExternalDurationMultiplier()));
      const colorVal = getRippleColor(el);
      const bg = getRippleBg(colorVal);
      const ripple = getRippleNode(el);

      const size = RIPPLE_HALO_START_DIAMETER + 'px';
      const left = (rect.width / 2 - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      const top = (rect.height / 2 - RIPPLE_HALO_START_DIAMETER / 2) + 'px';

      ripple.style.cssText = 'display:block;position:absolute;border-radius:50%;pointer-events:none;'
        + 'width:' + size + ';height:' + size + ';left:' + left + ';top:' + top + ';'
        + '--ripple-duration:' + scaledDuration + 'ms;--ripple-blur:blur(' + RIPPLE_HALO_BLUR + 'px);'
        + '--ripple-final-scale:' + haloFinalScale + ';'
        + 'background:' + bg + ';transform:scale(1) translate3d(0,0,0);backface-visibility:hidden;contain:strict;';

      el.appendChild(ripple);
      let s = activeRipples.get(el);
      if (!s) { s = new Set(); activeRipples.set(el, s); }
      s.add(ripple);

      requestAnimationFrame(() => {
        ripple.classList.add('animating');
        animateRipple(ripple, haloFinalScale, scaledDuration);
      });
      setTimeout(() => {
        fadeOutAndRemoveRipple(ripple, 'auto', el);
        try { if (s && s.delete) s.delete(ripple); } catch (err) { /* ignore */ }
      }, Math.max(120, scaledDuration - 120));
    });
  }

  // Touch/scroll heuristics: minimal, low allocation
  let isRapidScrollFlag = false;
  (function installTouchHandlers() {
    let lastScrollTime = 0;
    let touchMoved = false;
    let lastTouchX = 0, lastTouchY = 0;
    let touchHistory = [];
    function onTouchStart(e) {
      const t = e.touches ? e.touches[0] : e;
      lastTouchX = t.clientX; lastTouchY = t.clientY;
      touchMoved = false;
      touchHistory.length = 0;
      touchHistory.push({ t: now(), x: lastTouchX, y: lastTouchY });
      isRapidScrollFlag = false;
    }
    function onTouchMove(e) {
      const t = e.touches ? e.touches[0] : e;
      const dx = t.clientX - lastTouchX, dy = t.clientY - lastTouchY;
      if (!touchMoved && (Math.abs(dx) > 18 || Math.abs(dy) > 18)) touchMoved = true;
      lastTouchX = t.clientX; lastTouchY = t.clientY;
      const timeNow = now();
      const last = touchHistory[touchHistory.length - 1];
      if (!last || (timeNow - last.t) > 8) touchHistory.push({ t: timeNow, x: lastTouchX, y: lastTouchY });
      if (touchHistory.length > 4) touchHistory.shift();
      // compute velocity cheaply
      if (touchHistory.length >= 2) {
        const first = touchHistory[0], last2 = touchHistory[touchHistory.length - 1];
        const dt = Math.max(1, last2.t - first.t);
        const v = Math.hypot(last2.x - first.x, last2.y - first.y) / dt;
        if (v > 1.6) isRapidScrollFlag = true;
      }
    }
    function onTouchEnd() {
      touchHistory.length = 0;
      touchMoved = false;
    }
    function onScroll() {
      const t = now();
      if (t - lastScrollTime < 40) {
        isRapidScrollFlag = true;
        setTimeout(() => { isRapidScrollFlag = false; }, 120);
      }
      lastScrollTime = t;
    }

    if (typeof document !== 'undefined') {
      document.addEventListener('touchstart', onTouchStart, { passive: true });
      document.addEventListener('touchmove', onTouchMove, { passive: true });
      document.addEventListener('touchend', onTouchEnd, { passive: true });
      document.addEventListener('touchcancel', onTouchEnd, { passive: true });
      window.addEventListener('scroll', onScroll, { passive: true });
    }
  })();

  // Observer/upgrade helpers (kept semantics)
  function upgradeElement(el) {
    if (upgradedElements.has(el)) return;
    el.classList.add(SURFACE_CLASS);
    upgradedElements.add(el);
  }

  let lastUpgradeAll = 0;
  let cachedWaveNodes = [];
  function querySelectorAllCached(sel) {
    const time = Date.now();
    if (sel === '[wave]' && (time - lastUpgradeAll < 5000) && cachedWaveNodes.length) return cachedWaveNodes;
    const nodes = Array.prototype.slice.call(document.querySelectorAll(sel));
    if (sel === '[wave]') {
      cachedWaveNodes = nodes;
      lastUpgradeAll = time;
    }
    return nodes;
  }

  let observer = null;
  function observeDom() {
    if (observer) return;
    if (typeof IntersectionObserver === 'undefined') {
      // fallback: upgrade existing nodes immediately
      const nodes = querySelectorAllCached('[wave]');
      for (let i = 0; i < nodes.length; i++) upgradeElement(nodes[i]);
      return;
    }
    observer = new IntersectionObserver(entries => {
      for (let i = 0; i < entries.length; i++) {
        if (entries[i].isIntersecting) upgradeElement(entries[i].target);
      }
    }, { threshold: 0.01 });
    const nodes = querySelectorAllCached('[wave]');
    for (let i = 0; i < nodes.length; i++) observer.observe(nodes[i]);
  }

  // Global handlers
  function globalPointerHandler(e) {
    if (e.button && e.button !== 0) return;
    const el = e.target && e.target.closest ? e.target.closest('[wave]') : null;
    if (!el || !document.body.contains(el)) return;
    if (!upgradedElements.has(el)) upgradeElement(el);
    onPointerDown.call(el, e);
  }
  function globalKeyHandler(e) {
    const el = e.target && e.target.closest ? e.target.closest('[wave]') : null;
    if (!el || !document.body.contains(el)) return;
    if (!upgradedElements.has(el)) upgradeElement(el);
    onKeyDown.call(el, e);
  }
  function installGlobalHandlers() {
    if (installGlobalHandlers.done) return;
    document.addEventListener('pointerdown', globalPointerHandler, { passive: true });
    document.addEventListener('keydown', globalKeyHandler, { passive: true, capture: true });
    installGlobalHandlers.done = true;
  }

  // Auto-load CSS and settings (kept behavior)
  let waveEffectCSSLoaded = false, waveSettingLoaded = false, waveJsonLoaded = false;
  function autoLoadWaveEffectCSS() {
    if (waveEffectCSSLoaded) return;
    const cssPath = 'https://marcufer.github.io/Marcumat.js/assets/wave-effect.min.css';
    for (let i = 0; i < document.querySelectorAll('link[rel="stylesheet"]').length; i++) {
      const link = document.querySelectorAll('link[rel="stylesheet"]')[i];
      if (link.href && link.href.indexOf(cssPath) !== -1) { waveEffectCSSLoaded = true; return; }
    }
    if (!document.querySelector('link[href="' + cssPath + '"]')) {
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = cssPath;
      link.onload = function () { waveEffectCSSLoaded = true; };
      link.onerror = function () { waveEffectCSSLoaded = false; };
      document.head.appendChild(link);
    }
  }

  function autoLoadWaveSettingCSS() {
    if (waveSettingLoaded) return;
    const links = document.querySelectorAll('link[rel="stylesheet"]');
    for (let i = 0; i < links.length; i++) {
      const href = links[i].href || '';
      if (/wave-setting(\.min)?\.css([?#].*)?$/i.test(href)) { waveSettingLoaded = true; return; }
    }
    // best-effort: try a few likely paths (non-blocking)
    const pathBases = ['/wave-setting.css', '/css/wave-setting.css', '/assets/wave-setting.css'];
    (function tryNext(idx) {
      if (idx >= pathBases.length) return;
      const href = pathBases[idx];
      if (document.querySelector('link[href="' + href + '"]')) return tryNext(idx + 1);
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = href;
      link.onload = function () { waveSettingLoaded = true; };
      link.onerror = function () { tryNext(idx + 1); };
      document.head.appendChild(link);
    })(0);
  }

  function autoLoadWaveSettingJSON(callback) {
    if (waveJsonLoaded) { if (callback) callback({}); return; }
    const pathBases = ['/wave-setting.json', '/css/wave-setting.json', '/assets/wave-setting.json'];
    (function tryNext(idx) {
      if (idx >= pathBases.length) { waveJsonLoaded = true; if (callback) callback({}); return; }
      fetch(pathBases[idx], { method: 'GET', credentials: 'same-origin' })
        .then(r => r.ok ? r.json() : null)
        .then(json => {
          if (json && typeof json === 'object') {
            waveJsonLoaded = true;
            if (callback) callback(json);
          } else tryNext(idx + 1);
        })
        .catch(() => tryNext(idx + 1));
    })(0);
  }

  // Init
  function upgradeAll() {
    const nodes = querySelectorAllCached('[wave]');
    for (let i = 0; i < nodes.length; i++) upgradeElement(nodes[i]);
  }

  function initWakeEffect() {
    autoLoadWaveEffectCSS();
    autoLoadWaveSettingCSS();
    autoLoadWaveSettingJSON(function (opts) {
      if (opts && opts.disableTapHighlight) {
        const style = document.createElement('style');
        style.textContent = '[wave]{-webkit-tap-highlight-color:transparent!important;tap-highlight-color:transparent!important;}';
        document.head.appendChild(style);
      }
      upgradeAll();
    });
    upgradeAll();
    observeDom();
    installGlobalHandlers();
    // touch handlers were installed earlier via IIFE
    window.addEventListener('beforeunload', function () {
      // cleanup hint
      try { ripplePools = new WeakMap(); } catch (e) { /* ignore */ }
    });
  }

  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initWakeEffect, { once: true });
    } else initWakeEffect();
  }

  // Developer API (unchanged)
  const config = {
    BASE_DURATION,
    MIN_DURATION,
    MAX_EXTRA,
    RIPPLE_HALO_START_DIAMETER,
    COVERAGE_EXPAND_RATIO,
    get RIPPLE_FADE_DURATION_AUTO() { return RIPPLE_FADE_DURATION_AUTO; },
    get RIPPLE_FADE_DURATION_MANUAL() { return RIPPLE_FADE_DURATION_MANUAL; },
    setFadeDurationAuto(ms) { if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_AUTO = ms | 0; },
    setFadeDurationManual(ms) { if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_MANUAL = ms | 0; }
  };

  return {
    upgradeAll,
    upgradeElement,
    clearRipples,
    config,
    settings: {}
  };
}));