/**
 * wave-effect.ultra-lite.v6.js (improved blur/transition tuning for smoother, higher-quality ripples)
 * - Tweaks: smoother blur timing, slightly rebalanced durations and easing for a professional feel.
 * - Adds per-ripple blur-duration tuning so the blur ramps up during expansion and eases out during fade.
 * - Honors prefers-reduced-motion via CSS; JS keeps durations minimal in that case.
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) define([], factory);
  else if (typeof exports === 'object' && typeof module !== 'undefined') module.exports = factory();
  else root.WakeEffect = factory();
}(typeof self !== 'undefined' ? self : this, function () {
  'use strict';

  // ---- (constants/logic with tuned values) ----
  const RIPPLE_CLASS = 'ripple';
  const SURFACE_CLASS = 'ripple-surface';
  const BASE_DURATION = 450;
  const MIN_DURATION = 450;
  const MAX_EXTRA = 0.1;
  const RIPPLE_HALO_START_DIAMETER = 18;
  // tuned blur: balanced to be visible but cheap; small float yields smooth GPU blur
  const RIPPLE_HALO_BLUR = 0.9;
  const COVERAGE_EXPAND_RATIO = 0.21;
  const MAX_RIPPLES_PER_ELEMENT = 6;
  // slightly reduced multiplier for snappier but smooth feel
  const INTERNAL_SPEED_MULTIPLIER = 1.3;
  let RIPPLE_FADE_DURATION_AUTO = 700;
  let RIPPLE_FADE_DURATION_MANUAL = 700;
  const elData = new WeakMap();
  const activeRipples = new WeakMap();
  let extMul = { t: 0, v: 1 };
  const EXTERNAL_MULTIPLIER_TTL = 20000;
  const GRADIENT_TTL = 20000;
  const DEFAULT_GRADIENT = 'radial-gradient(circle, rgba(16, 20, 28, 0.2) 0%, transparent 80%)';
  const reWaveColor = /(?:^|\s)c\s*[=:]?\s*([#a-zA-Z0-9(),.\s]+)/i;
  const reFuncColor = /^(rgba?|hsla?)\(([^)]+)\)$/i;
  const now = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  const sqrt2 = Math.SQRT2 || Math.sqrt(2);
  const _tpl = (function () {
    const s = document.createElement('span');
    s.className = RIPPLE_CLASS + ' dynamic-halo-pro';
    s.style.contain = 'strict';
    s.style.display = 'none';
    return s;
  })();
  const q = [];
  let rafId = null;
  function schedule(fn) {
    q.push(fn);
    if (!rafId) {
      rafId = requestAnimationFrame(() => {
        for (let i = 0; i < q.length; i++) {
          try { q[i](); } catch (e) { }
        }
        q.length = 0;
        rafId = null;
      });
    }
  }
  (function setupInvalidation() {
    let t = 0;
    function invalidateAll() {}
    if (typeof window !== 'undefined') {
      window.addEventListener('resize', () => { clearTimeout(t); t = setTimeout(invalidateAll, 120); }, { passive: true });
      window.addEventListener('scroll', () => { clearTimeout(t); t = setTimeout(invalidateAll, 220); }, { passive: true });
    }
  })();
  function getExternalDurationMultiplier() {
    const t = Date.now();
    if ((t - extMul.t) < EXTERNAL_MULTIPLIER_TTL) return extMul.v;
    try {
      const s = getComputedStyle(document.documentElement).getPropertyValue('--ripple-duration-multiplier').trim();
      const v = parseFloat(s);
      extMul.t = t;
      extMul.v = (isFinite(v) && v > 0) ? v : 1;
      return extMul.v;
    } catch (e) { return 1; }
  }
  function getElData(el) {
    let d = elData.get(el);
    if (!d) { d = { pool: [], color: undefined, gradient: undefined, rect: undefined }; elData.set(el, d); }
    return d;
  }
  function computeGradient(color) {
    if (!color) return DEFAULT_GRADIENT;
    const d = now();
    if (!computeGradient._map) computeGradient._map = new Map();
    const gm = computeGradient._map;
    const entry = gm.get(color);
    if (entry && (d - entry.t) < GRADIENT_TTL) return entry.v;
    const cleaned = (color || '').replace(/\s+/g, '');
    const m = reFuncColor.exec(cleaned);
    let out;
    if (m) {
      const parts = m[2].split(',');
      const alpha = (parts[3] !== undefined) ? parseFloat(parts[3]) : 1;
      
      // --- เปลี่ยนแปลงตรงนี้ ---
      // คำนวณ alpha ของ ripple ให้นุ่มนวลและมองเห็นชัดเจน (ขั้นต่ำ 0.15)
      const rippleAlpha = Math.min(1, Math.max(alpha, 0.15));
      const prefix = m[1].startsWith('hsl') ? 'hsla' : 'rgba';
      const core = parts.slice(0, 3).join(',');
      // สร้าง gradient แบบใหม่ที่นุ่มนวล
      out = 'radial-gradient(circle, ' + prefix + '(' + core + ',' + rippleAlpha + ') 10%, transparent 80%)';
      
    } else {
      // --- เปลี่ยนแปลงตรงนี้ ---
      // ใช้ hex alpha '26' (ประมาณ 15%) และไล่สีแบบนุ่มนวล
      out = 'radial-gradient(circle, ' + color + '26 10%, transparent 80%)';
    }
    gm.set(color, { v: out, t: d });
    return out;
  }

  function getRippleNode(el) {
    const d = getElData(el);
    let pool = d.pool;
    let node = pool.pop();
    if (!node) node = _tpl.cloneNode(false);
    node.classList.remove('animating', 'fading');
    node.style.cssText = 'display:block;contain:strict;';
    return node;
  }
  function releaseRippleNode(el, node) {
    node.classList.remove('animating', 'fading');
    node.style.opacity = 0;
    node.style.removeProperty('will-change');
    requestAnimationFrame(() => {
      node.style.display = 'none';
      if (node.parentNode === el) el.removeChild(node);
      const d = getElData(el);
      if (!d.pool) d.pool = [];
      if (d.pool.length < MAX_RIPPLES_PER_ELEMENT) d.pool.push(node);
    });
  }
  const DEFAULT_COLOR_CACHE_TTL = 20000;
  function getDefaultRippleColor(el) {
    const d = getElData(el);
    const stamped = d._colorStamp;
    const t = now();
    if (stamped && d.color !== undefined && (t - stamped) < DEFAULT_COLOR_CACHE_TTL) return d.color;
    let node = el, found = null;
    while (node) {
      try {
        const s = getComputedStyle(node);
        const val = s.getPropertyValue('--ripple-default-color').trim();
        if (val) { found = val; break; }
      } catch (e) { break; }
      node = node.parentElement;
    }
    d.color = found;
    d._colorStamp = t;
    return found;
  }
  function getRippleColor(el) {
    if (el.hasAttribute && el.hasAttribute('data-ripple-color')) {
      const v = el.getAttribute('data-ripple-color');
      if (v && v.trim()) return v.trim();
    }
    const attr = (el.getAttribute && el.getAttribute('wave')) || '';
    const m = reWaveColor.exec(attr);
    if (m && m[1]) {
      const v = m[1].trim();
      if (v) return v;
    }
    return getDefaultRippleColor(el) || null;
  }
  function maximalExpandedCoverageRadius(x, y, width, height) {
    const dx0 = x, dx1 = width - x, dy0 = y, dy1 = height - y;
    let max = dx0;
    if (dy0 > max) max = dy0;
    if (dx1 > max) max = dx1;
    if (dy1 > max) max = dy1;
    const h0 = Math.hypot(dx0, dy0); if (h0 > max) max = h0;
    const h1 = Math.hypot(dx1, dy0); if (h1 > max) max = h1;
    const h2 = Math.hypot(dx0, dy1); if (h2 > max) max = h2;
    const h3 = Math.hypot(dx1, dy1); if (h3 > max) max = h3;
    const cx = Math.abs(width / 2 - x); if (cx > max) max = cx;
    const cy = Math.abs(height / 2 - y); if (cy > max) max = cy;
    const diagHalf = Math.hypot(width, height) / 2; if (diagHalf > max) max = diagHalf;
    const expand = Math.max(width, height) * COVERAGE_EXPAND_RATIO;
    const mOut = Math.max(max * sqrt2 + expand, 28);
    return mOut;
  }
  function smartDuration(x, y, width, height) {
    const cx = width / 2, cy = height / 2;
    const maxDist = maximalExpandedCoverageRadius(cx, cy, width, height);
    const pointerDist = Math.hypot(x - cx, y - cy);
    const ratio = Math.min(pointerDist / maxDist, 1);
    const duration = BASE_DURATION - (BASE_DURATION - MIN_DURATION) * (ratio * MAX_EXTRA);
    return Math.round(duration);
  }
  function animateRipple(node, scale, duration) {
    node.style.willChange = 'transform, opacity, filter';
    node.style.transform = 'translate3d(0,0,0) scale(' + scale + ')';
    node.style.backfaceVisibility = 'hidden';
    const removeAfter = Math.max(120, duration + 60);
    setTimeout(() => {
      try { node.style.removeProperty('will-change'); } catch (e) { }
    }, removeAfter);
  }
  function fadeOutAndRemoveRipple(ripple, fadeType, el) {
    if (!ripple) return;
    const duration = (fadeType === 'auto') ? RIPPLE_FADE_DURATION_AUTO : RIPPLE_FADE_DURATION_MANUAL;
    ripple.classList.add('fading');
    ripple.style.setProperty('--ripple-fade-duration', duration + 'ms');
    ripple.style.willChange = 'opacity,transform,filter';
    let removed = false;
    function onEnd(e) {
      if (removed) return;
      if (!e || e.propertyName === 'opacity') {
        removed = true;
        ripple.removeEventListener('transitionend', onEnd);
        try { ripple.style.removeProperty('will-change'); } catch (err) { }
        const set = activeRipples.get(el);
        if (set && set.delete) set.delete(ripple);
        releaseRippleNode(el, ripple);
      }
    }
    ripple.addEventListener('transitionend', onEnd);
    setTimeout(onEnd, duration + 160);
  }
  function clearRipples(el) {
    const nodes = el.querySelectorAll('.' + RIPPLE_CLASS);
    for (let i = 0; i < nodes.length; i++) fadeOutAndRemoveRipple(nodes[i], 'manual', el);
    activeRipples.set(el, new Set());
  }
  function computePointerLocal(el, pointer) {
    const rect = el.getBoundingClientRect();
    const vv = (typeof window !== 'undefined' && window.visualViewport) ? window.visualViewport : null;
    const vx = vv ? (vv.offsetLeft || 0) : 0;
    const vy = vv ? (vv.offsetTop || 0) : 0;
    const cx = (pointer.clientX !== undefined ? pointer.clientX : (pointer.pageX - (window.pageXOffset || 0))) - vx;
    const cy = (pointer.clientY !== undefined ? pointer.clientY : (pointer.pageY - (window.pageYOffset || 0))) - vy;
    const x = cx - rect.left;
    const y = cy - rect.top;
    const w = rect.width || 0;
    const h = rect.height || 0;
    const clampedX = x < 0 ? 0 : (x > w ? w : x);
    const clampedY = y < 0 ? 0 : (y > h ? h : y);
    return { rect, x: clampedX, y: clampedY, w, h };
  }

  // == Delegate Ripple Effect Support with correct fade ==
  function findWaveDelegateEl(originEl, event) {
    let el = originEl;
    while (el && el !== document.body) {
      if (el.hasAttribute && el.hasAttribute('wave-delegate')) {
        const selector = el.getAttribute('wave-delegate');
        let delegateTarget = null;
        try {
          delegateTarget = selector ? el.querySelector(selector) : null;
        } catch {}
        if (delegateTarget && delegateTarget.hasAttribute('wave')) {
          const rect = delegateTarget.getBoundingClientRect();
          let clientX = 0, clientY = 0;
          if (event.touches && event.touches[0]) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
          } else {
            clientX = event.clientX;
            clientY = event.clientY;
          }
          const fakeEvent = {
            ...event,
            clientX,
            clientY,
            touches: undefined,
            _ripple_from_delegate: true,
            _ripple_relative_to: delegateTarget,
            _ripple_override_coords: {
              rect,
              x: clientX - rect.left,
              y: clientY - rect.top,
              w: rect.width,
              h: rect.height
            }
          };
          // Mark the delegate target for fade control
          delegateTarget._ripple_delegate_active = true;
          onPointerDown.call(delegateTarget, fakeEvent);

          // Fix: Forward pointerup/touchend/touchcancel from parent to child to ensure fade
          function forwardEndRipple(ev) {
            if (!delegateTarget._ripple_delegate_active) return;
            delegateTarget._ripple_delegate_active = false;
            let eventType = ev.type;
            if (eventType !== "pointerup" && eventType !== "pointerleave" && eventType !== "touchend" && eventType !== "touchcancel") return;
            // Dispatch pointerup/touchend directly to the child for fade
            let eventObj;
            if (eventType.startsWith('pointer')) {
              eventObj = new PointerEvent(eventType, {clientX, clientY, bubbles:true});
            } else if (window.TouchEvent && (eventType.startsWith('touch'))) {
              // Make a minimal synthetic TouchEvent for compatibility
              try {
                eventObj = new TouchEvent(eventType, {bubbles:true, touches:[], changedTouches:[{clientX, clientY}]});
              } catch {
                // fallback: use PointerEvent instead
                eventObj = new PointerEvent('pointerup', {clientX, clientY, bubbles:true});
              }
            } else {
              eventObj = new PointerEvent('pointerup', {clientX, clientY, bubbles:true});
            }
            delegateTarget.dispatchEvent(eventObj);
            removeListeners();
          }
          function removeListeners() {
            el.removeEventListener('pointerup', forwardEndRipple);
            el.removeEventListener('pointerleave', forwardEndRipple);
            el.removeEventListener('touchend', forwardEndRipple);
            el.removeEventListener('touchcancel', forwardEndRipple);
          }
          el.addEventListener('pointerup', forwardEndRipple, { passive: true, once: true });
          el.addEventListener('pointerleave', forwardEndRipple, { passive: true, once: true });
          el.addEventListener('touchend', forwardEndRipple, { passive: true, once: true });
          el.addEventListener('touchcancel', forwardEndRipple, { passive: true, once: true });

          return true;
        }
      }
      el = el.parentElement;
    }
    return false;
  }

  function onPointerDown(e) {
    if (e.button && e.button !== 0) return;
    const el = this;
    if (!el) return;
    if (isRapidScrollFlag) return;
    let p;
    if (e._ripple_override_coords) {
      p = e._ripple_override_coords;
    } else {
      const pointer = e.touches ? e.touches[0] : e;
      p = computePointerLocal(el, pointer);
    }
    const radius = maximalExpandedCoverageRadius(p.x, p.y, p.w, p.h);
    const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
    const baseDuration = smartDuration(p.x, p.y, p.w, p.h);
    const scaledDuration = Math.max(120, Math.round(baseDuration * INTERNAL_SPEED_MULTIPLIER * getExternalDurationMultiplier()));
    const colorVal = getRippleColor(el);
    const bg = computeGradient(colorVal);

    // Compute a blur-duration proportionally to the ripple duration for a natural ramp
    const blurDuration = Math.max(90, Math.round(scaledDuration * 0.45));

    // If user prefers reduced motion, shorten transitions (CSS also handles it)
    let prefersReduced = false;
    try {
      prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    } catch (err) { /* ignore */ }
    const effectiveBlur = prefersReduced ? 0 : RIPPLE_HALO_BLUR;

    schedule(function () {
      const ripple = getRippleNode(el);
      const size = RIPPLE_HALO_START_DIAMETER + 'px';
      const left = (p.x - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      const top = (p.y - RIPPLE_HALO_START_DIAMETER / 2) + 'px';

      // Per-ripple CSS variable tuning:
      // - --ripple-duration is the main transform scale timing
      // - --ripple-blur defines the current blur (e.g., blur(0.9px))
      // - --ripple-blur-duration controls how quickly the blur ramps
      ripple.style.cssText =
        'display:block;position:absolute;border-radius:50%;pointer-events:none;' +
        'width:' + size + ';height:' + size + ';left:' + left + ';top:' + top + ';' +
        '--ripple-duration:' + scaledDuration + 'ms;' +
        '--ripple-blur: ' + (effectiveBlur ? ('blur(' + effectiveBlur + 'px)') : 'none') + ';' +
        '--ripple-blur-duration: ' + blurDuration + 'ms;' +
        '--ripple-final-scale:' + haloFinalScale + ';' +
        'background:' + bg + ';transform:scale(1) translate3d(0,0,0);backface-visibility:hidden;contain:strict;';

      el.appendChild(ripple);
      let set = activeRipples.get(el);
      if (!set) { set = new Set(); activeRipples.set(el, set); }
      set.add(ripple);
      let expansionEnded = false;
      function onTransformEnd(evt) {
        if (evt && evt.propertyName !== 'transform') return;
        expansionEnded = true;
        ripple.removeEventListener('transitionend', onTransformEnd);
      }
      ripple.addEventListener('transitionend', onTransformEnd);
      function endRipple() {
        if (!ripple.parentNode) return;
        if (!expansionEnded) fadeOutAndRemoveRipple(ripple, 'auto', el);
        else fadeOutAndRemoveRipple(ripple, 'manual', el);
        try { if (set && set.delete) set.delete(ripple); } catch (e) { }
        removeListeners();
      }
      function removeListeners() {
        el.removeEventListener('pointerup', endRipple);
        el.removeEventListener('pointerleave', endRipple);
        el.removeEventListener('touchend', endRipple);
        el.removeEventListener('touchcancel', endRipple);
      }
      el.addEventListener('pointerup', endRipple, { passive: true, once: true });
      el.addEventListener('pointerleave', endRipple, { passive: true, once: true });
      el.addEventListener('touchend', endRipple, { passive: true, once: true });
      el.addEventListener('touchcancel', endRipple, { passive: true, once: true });

      // Kick off the expansion on next frame so transitions apply smoothly
      requestAnimationFrame(function () {
        ripple.classList.add('animating');
        animateRipple(ripple, haloFinalScale, scaledDuration);
        // Guard: if transitionend never fires, ensure the ripple eventually goes to expansion-ended state
        setTimeout(function () {
          if (!expansionEnded) {
            expansionEnded = true;
            try { ripple.removeEventListener('transitionend', onTransformEnd); } catch (e) { }
          }
        }, scaledDuration + 220);
      });
    });
  }

  function onKeyDown(e) {
    if (![' ', 'Enter'].includes(e.key)) return;
    const el = this;
    clearRipples(el);
    schedule(function () {
      const rect = (el.getBoundingClientRect && el.getBoundingClientRect()) || { width: 0, height: 0 };
      const x = rect.width / 2, y = rect.height / 2;
      const radius = maximalExpandedCoverageRadius(x, y, rect.width, rect.height);
      const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
      const baseDuration = BASE_DURATION;
      const scaledDuration = Math.max(120, Math.round(baseDuration * INTERNAL_SPEED_MULTIPLIER * getExternalDurationMultiplier()));
      const colorVal = getRippleColor(el);
      const bg = computeGradient(colorVal);
      const ripple = getRippleNode(el);
      const size = RIPPLE_HALO_START_DIAMETER + 'px';
      const left = (rect.width / 2 - RIPPLE_HALO_START_DIAMETER / 2) + 'px';
      const top = (rect.height / 2 - RIPPLE_HALO_START_DIAMETER / 2) + 'px';

      // Key press should feel snappy but still smooth: use a short blur-duration proportion
      const blurDuration = Math.max(90, Math.round(scaledDuration * 0.4));
      const prefersReduced = (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);
      const effectiveBlur = prefersReduced ? 0 : RIPPLE_HALO_BLUR;

      ripple.style.cssText =
        'display:block;position:absolute;border-radius:50%;pointer-events:none;' +
        'width:' + size + ';height:' + size + ';left:' + left + ';top:' + top + ';' +
        '--ripple-duration:' + scaledDuration + 'ms;' +
        '--ripple-blur: ' + (effectiveBlur ? ('blur(' + effectiveBlur + 'px)') : 'none') + ';' +
        '--ripple-blur-duration: ' + blurDuration + 'ms;' +
        '--ripple-final-scale:' + haloFinalScale + ';' +
        'background:' + bg + ';transform:scale(1) translate3d(0,0,0);backface-visibility:hidden;contain:strict;';
      el.appendChild(ripple);
      let set = activeRipples.get(el);
      if (!set) { set = new Set(); activeRipples.set(el, set); }
      set.add(ripple);
      requestAnimationFrame(function () {
        ripple.classList.add('animating');
        animateRipple(ripple, haloFinalScale, scaledDuration);
      });
      setTimeout(function () {
        fadeOutAndRemoveRipple(ripple, 'auto', el);
        try { if (set && set.delete) set.delete(ripple); } catch (e) { }
      }, Math.max(120, scaledDuration - 120));
    });
  }

  let isRapidScrollFlag = false;
  (function installTouchHandlers() {
    if (typeof document === 'undefined') return;
    let lastScroll = 0;
    let lastX = 0, lastY = 0;
    let hist = [];
    function onTouchStart(e) {
      const t = e.touches ? e.touches[0] : e;
      lastX = t.clientX; lastY = t.clientY;
      hist.length = 0; hist.push({ t: now(), x: lastX, y: lastY });
      isRapidScrollFlag = false;
    }
    function onTouchMove(e) {
      const t = e.touches ? e.touches[0] : e;
      const dx = t.clientX - lastX, dy = t.clientY - lastY;
      lastX = t.clientX; lastY = t.clientY;
      const ts = now();
      const last = hist[hist.length - 1];
      if (!last || (ts - last.t) > 8) hist.push({ t: ts, x: lastX, y: lastY });
      if (hist.length > 4) hist.shift();
      if (hist.length >= 2) {
        const first = hist[0], last2 = hist[hist.length - 1];
        const dt = Math.max(1, last2.t - first.t);
        const v = Math.hypot(last2.x - first.x, last2.y - first.y) / dt;
        if (v > 1.6) isRapidScrollFlag = true;
      }
    }
    function onTouchEnd() { hist.length = 0; }
    function onScroll() {
      const t = now();
      if (t - lastScroll < 40) {
        isRapidScrollFlag = true;
        setTimeout(function () { isRapidScrollFlag = false; }, 120);
      }
      lastScroll = t;
    }
    document.addEventListener('touchstart', onTouchStart, { passive: true });
    document.addEventListener('touchmove', onTouchMove, { passive: true });
    document.addEventListener('touchend', onTouchEnd, { passive: true });
    document.addEventListener('touchcancel', onTouchEnd, { passive: true });
    window.addEventListener('scroll', onScroll, { passive: true });
  })();

  function upgradeElement(el) {
    if (!el) return;
    if (el.classList && el.classList.contains(SURFACE_CLASS)) return;
    el.classList.add(SURFACE_CLASS);
    getElData(el);
  }
  function upgradeAll() {
    const nodes = document.querySelectorAll('[wave]');
    for (let i = 0; i < nodes.length; i++) upgradeElement(nodes[i]);
  }
  function observeDom() {
    if (typeof IntersectionObserver === 'undefined') { upgradeAll(); return; }
    const obs = new IntersectionObserver(function (entries) {
      for (let i = 0; i < entries.length; i++) {
        if (entries[i].isIntersecting) upgradeElement(entries[i].target);
      }
    }, { threshold: 0.01 });
    const nodes = document.querySelectorAll('[wave]');
    for (let i = 0; i < nodes.length; i++) obs.observe(nodes[i]);
  }
  function globalPointerHandler(e) {
    if (e.button && e.button !== 0) return;
    if (findWaveDelegateEl(e.target, e)) return;
    const el = e.target && e.target.closest ? e.target.closest('[wave]') : null;
    if (!el || !document.body.contains(el)) return;
    if (!el.classList.contains(SURFACE_CLASS)) upgradeElement(el);
    onPointerDown.call(el, e);
  }
  function globalKeyHandler(e) {
    const el = e.target && e.target.closest ? e.target.closest('[wave]') : null;
    if (!el || !document.body.contains(el)) return;
    if (!el.classList.contains(SURFACE_CLASS)) upgradeElement(el);
    onKeyDown.call(el, e);
  }
  function installGlobalHandlers() {
    if (installGlobalHandlers.done) return;
    document.addEventListener('pointerdown', globalPointerHandler, { passive: true });
    document.addEventListener('keydown', globalKeyHandler, { passive: true, capture: true });
    installGlobalHandlers.done = true;
  }
  let waveEffectCSSLoaded = false, waveSettingLoaded = false, waveJsonLoaded = false;
  function autoLoadWaveEffectCSS() {
    if (waveEffectCSSLoaded) return;
    const cssPath = 'https://marcufer.github.io/Marcumat.js/assets/wave-effect.min.css';
    const links = document.querySelectorAll('link[rel="stylesheet"]');
    for (let i = 0; i < links.length; i++) {
      const href = links[i].href || '';
      if (href.indexOf(cssPath) !== -1) { waveEffectCSSLoaded = true; return; }
    }
    if (!document.querySelector('link[href="' + cssPath + '"]')) {
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = cssPath;
      link.onload = function () { waveEffectCSSLoaded = true; };
      link.onerror = function () { waveEffectCSSLoaded = false; };
      document.head.appendChild(link);
    }
  }
  function autoLoadWaveSettingCSS() {
    if (waveSettingLoaded) return;
    const links = document.querySelectorAll('link[rel="stylesheet"]');
    for (let i = 0; i < links.length; i++) {
      const href = links[i].href || '';
      if (/wave-setting(\.min)?\.css([?#].*)?$/i.test(href)) { waveSettingLoaded = true; return; }
    }
    const pathBases = ['/wave-setting.css', '/css/wave-setting.css', '/assets/wave-setting.css'];
    (function tryNext(idx) {
      if (idx >= pathBases.length) return;
      const href = pathBases[idx];
      if (document.querySelector('link[href="' + href + '"]')) return tryNext(idx + 1);
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = href;
      link.onload = function () { waveSettingLoaded = true; };
      link.onerror = function () { tryNext(idx + 1); };
      document.head.appendChild(link);
    })(0);
  }
  function autoLoadWaveSettingJSON(callback) {
    if (waveJsonLoaded) { if (callback) callback({}); return; }
    const pathBases = ['/wave-setting.json', '/css/wave-setting.json', '/assets/wave-setting.json'];
    (function tryNext(idx) {
      if (idx >= pathBases.length) { waveJsonLoaded = true; if (callback) callback({}); return; }
      fetch(pathBases[idx], { method: 'GET', credentials: 'same-origin' })
        .then(r => r.ok ? r.json() : null)
        .then(json => {
          if (json && typeof json === 'object') { waveJsonLoaded = true; if (callback) callback(json); }
          else tryNext(idx + 1);
        })
        .catch(() => tryNext(idx + 1));
    })(0);
  }
  function initWakeEffect() {
    autoLoadWaveEffectCSS();
    autoLoadWaveSettingCSS();
    autoLoadWaveSettingJSON(function (opts) {
      if (opts && opts.disableTapHighlight) {
        const style = document.createElement('style');
        style.textContent = '[wave]{-webkit-tap-highlight-color:transparent!important;tap-highlight-color:transparent!important;}';
        document.head.appendChild(style);
      }
      upgradeAll();
    });
    upgradeAll();
    observeDom();
    installGlobalHandlers();
    window.addEventListener('beforeunload', function () { });
  }
  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initWakeEffect, { once: true });
    else initWakeEffect();
  }
  const config = {
    BASE_DURATION,
    MIN_DURATION,
    MAX_EXTRA,
    RIPPLE_HALO_START_DIAMETER,
    COVERAGE_EXPAND_RATIO,
    get RIPPLE_FADE_DURATION_AUTO() { return RIPPLE_FADE_DURATION_AUTO; },
    get RIPPLE_FADE_DURATION_MANUAL() { return RIPPLE_FADE_DURATION_MANUAL; },
    setFadeDurationAuto(ms) { if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_AUTO = ms | 0; },
    setFadeDurationManual(ms) { if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_MANUAL = ms | 0; }
  };
  return {
    upgradeAll,
    upgradeElement,
    clearRipples,
    config,
    settings: {}
  };
}));
