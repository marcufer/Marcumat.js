/**
 * wave-effect.ultra-optimized.js (improved for minimal resource & ultra smoothness, scroll-aware, enhanced for finger intent)
 * - Prevents ripple during rapid scroll, finger intent-aware
 * - Minimized DOM access & getBoundingClientRect
 * - Ripple pool per element
 * - Passive event, non-blocking scroll
 * - All feature parity and quality maintained
 * - For use with wave-effect.min.css (unchanged)
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = factory();
  } else {
    root.WakeEffect = factory();
  }
}(typeof self !== 'undefined' ? self : this, function() {
  'use strict';

  // --- Constants & state
  const RIPPLE_CLASS = 'ripple';
  const SURFACE_CLASS = 'ripple-surface';
  const BASE_DURATION = 490;
  const MIN_DURATION = 370;
  const MAX_EXTRA = 0.17;
  const MIN_RIPPLE_INTERVAL = 150;
  const GLOBAL_MIN_RIPPLE_INTERVAL = 100;
  const GLOBAL_MAX_RIPPLES = 7;
  let RIPPLE_FADE_DURATION_AUTO = 800;
  let RIPPLE_FADE_DURATION_MANUAL = 500;
  const RIPPLE_HALO_START_DIAMETER = 18;
  const RIPPLE_HALO_BLUR = 0.8;
  const COVERAGE_EXPAND_RATIO = 0.2;
  let lastGlobalRippleTime = 0;
  let globalActiveWavesCount = 0;
  const lastAllowed = new WeakMap();
  const activeRipples = new WeakMap();
  let waveSettingLoaded = false;
  let waveJsonLoaded = false;
  let waveEffectCSSLoaded = false;
  const settings = { disableTapHighlight: false };
  const upgradedElements = new WeakSet();
  let lastUpgradeAll = 0;
  let cachedWaveNodes = [];

  function querySelectorAllCached(sel) {
    const now = Date.now();
    if (sel === '[wave]' && (now - lastUpgradeAll < 2500) && cachedWaveNodes.length > 0) {
      return cachedWaveNodes;
    }
    const nodes = Array.from(document.querySelectorAll(sel));
    if (sel === '[wave]') {
      cachedWaveNodes = nodes;
      lastUpgradeAll = now;
    }
    return nodes;
  }

  // --- Scroll and touch/finger intent detection
  let lastScrollTime = 0;
  let isRapidScrolling = false;
  let scrollThreshold = 80; // ms, tune as needed
  let advancedScrollAnalysis = {
    lastY: null,
    lastX: null,
    lastTime: null,
    velocityY: 0,
    velocityX: 0,
    accY: 0,
    accX: 0,
    rapid: false,
    lastIntentCheck: 0
  };
  // Track finger movement for scroll intent
  let fingerIntent = {
    down: false,
    startX: 0,
    startY: 0,
    lastX: 0,
    lastY: 0,
    startTime: 0,
    moved: false,
    totalDistance: 0,
    cancelRipple: false,
    cancelByMove: false
  };

  // --- Enhanced scroll & intent detection
  function analyzeScrollIntent(e) {
    // e: WheelEvent or TouchEvent
    const now = performance.now();
    let x, y;
    if (e.type.startsWith('touch') && e.touches && e.touches.length) {
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    } else if ('clientX' in e && 'clientY' in e) {
      x = e.clientX;
      y = e.clientY;
    } else {
      return;
    }

    if (advancedScrollAnalysis.lastTime) {
      const dt = now - advancedScrollAnalysis.lastTime;
      const dy = y - advancedScrollAnalysis.lastY;
      const dx = x - advancedScrollAnalysis.lastX;
      const vy = Math.abs(dy / dt);
      const vx = Math.abs(dx / dt);

      // Velocity threshold (px/ms) and Acceleration threshold
      if (dt < 300) {
        advancedScrollAnalysis.velocityY = vy;
        advancedScrollAnalysis.velocityX = vx;
        let accY = (vy - advancedScrollAnalysis.accY) / dt;
        let accX = (vx - advancedScrollAnalysis.accX) / dt;
        advancedScrollAnalysis.accY = vy;
        advancedScrollAnalysis.accX = vx;

        // "Rapid" if velocity or acceleration passes threshold (tune below for natural UX)
        advancedScrollAnalysis.rapid = (vy > 0.75 || vx > 0.75) || (Math.abs(accY) > 0.015 || Math.abs(accX) > 0.015);
      }
    }
    advancedScrollAnalysis.lastY = y;
    advancedScrollAnalysis.lastX = x;
    advancedScrollAnalysis.lastTime = now;
  }

  window.addEventListener('scroll', () => {
    const now = performance.now();
    if (now - lastScrollTime < scrollThreshold) {
      isRapidScrolling = true;
      clearTimeout(window._rapidScrollTimer);
      window._rapidScrollTimer = setTimeout(() => { isRapidScrolling = false; }, scrollThreshold * 2);
    }
    lastScrollTime = now;
  }, {passive:true});

  // Listen for wheel events for mouse scroll, also detect intent
  window.addEventListener('wheel', (e) => {
    analyzeScrollIntent(e);
    // If scroll is very fast, set rapid
    if (Math.abs(e.deltaY) > 70 || advancedScrollAnalysis.rapid) {
      isRapidScrolling = true;
      clearTimeout(window._rapidScrollTimer);
      window._rapidScrollTimer = setTimeout(() => { isRapidScrolling = false; }, scrollThreshold * 2);
    }
  }, {passive:true});

  // --- Touch intent detection for finger scroll
  window.addEventListener('touchstart', (e) => {
    if (!e.touches || !e.touches.length) return;
    fingerIntent.down = true;
    fingerIntent.startX = fingerIntent.lastX = e.touches[0].clientX;
    fingerIntent.startY = fingerIntent.lastY = e.touches[0].clientY;
    fingerIntent.startTime = performance.now();
    fingerIntent.moved = false;
    fingerIntent.totalDistance = 0;
    fingerIntent.cancelRipple = false;
    fingerIntent.cancelByMove = false;
  }, {passive:true, capture:true});

  window.addEventListener('touchmove', (e) => {
    if (!fingerIntent.down || !e.touches || !e.touches.length) return;
    const x = e.touches[0].clientX, y = e.touches[0].clientY;
    const dx = x - fingerIntent.lastX, dy = y - fingerIntent.lastY;
    fingerIntent.totalDistance += Math.hypot(dx, dy);
    fingerIntent.lastX = x;
    fingerIntent.lastY = y;
    if (!fingerIntent.moved && fingerIntent.totalDistance > 8) {
      fingerIntent.moved = true;
    }
    // If the move is fast or in a scroll direction, cancel ripple
    const dt = performance.now() - fingerIntent.startTime;
    const velocity = fingerIntent.totalDistance / Math.max(dt,1);
    // threshold: if big move in short time, or velocity > 2px/ms (fast swipe)
    if (fingerIntent.moved && (velocity > 1 || fingerIntent.totalDistance > 20)) {
      fingerIntent.cancelRipple = true;
      fingerIntent.cancelByMove = true;
    }
    // Also run enhanced scroll intent
    analyzeScrollIntent(e);
  }, {passive:true, capture:true});

  window.addEventListener('touchend', (e) => {
    fingerIntent.down = false;
    // Reset cancel after a short time window
    setTimeout(() => { fingerIntent.cancelRipple = false; fingerIntent.cancelByMove = false; }, 120);
  }, {passive:true, capture:true});

  // --- Ripple queue & rAF batcher
  const rippleQueue = new Set();
  let rippleRAF = null;
  function scheduleRipple(fn) {
    rippleQueue.add(fn);
    if (!rippleRAF) {
      rippleRAF = requestAnimationFrame(() => {
        for (const f of rippleQueue) f();
        rippleQueue.clear();
        rippleRAF = null;
      });
    }
  }

  // --- Ripple pool per element
  const MAX_RIPPLES_PER_ELEMENT = 3;
  const ripplePools = new WeakMap();
  function getRippleNode(el) {
    let pool = ripplePools.get(el);
    if (!pool) {
      pool = [];
      ripplePools.set(el, pool);
    }
    let node = pool.pop();
    if (!node) {
      node = document.createElement('span');
      node.className = RIPPLE_CLASS + ' dynamic-halo-pro';
    }
    node.classList.remove('animating','fading');
    node.style.cssText = '';
    node.style.display = 'block';
    return node;
  }
  function releaseRippleNode(el, node) {
    node.classList.remove('animating','fading');
    node.style.opacity = 0;
    setTimeout(() => {
      node.style.display = 'none';
      if (node.parentNode) node.parentNode.removeChild(node);
      let pool = ripplePools.get(el);
      if (!pool) pool = [], ripplePools.set(el, pool);
      if (!pool.includes(node) && pool.length < MAX_RIPPLES_PER_ELEMENT) pool.push(node);
    }, 80);
  }

  // --- CSS Loader (unchanged)
  function autoLoadWaveEffectCSS() {
    if (waveEffectCSSLoaded) return;
    const cssPath = 'https://marcufer.github.io/Marcumat.js/assets/wave-effect.min.css';
    for (const link of document.querySelectorAll('link[rel="stylesheet"]')) {
      if (link.href && link.href.indexOf(cssPath) !== -1) {
        waveEffectCSSLoaded = true; return;
      }
    }
    if (!document.querySelector(`link[href="${cssPath}"]`)) {
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = cssPath;
      link.onload = () => { waveEffectCSSLoaded = true; };
      link.onerror = () => { waveEffectCSSLoaded = false; };
      document.head.appendChild(link);
    }
  }
  function makeMultifyCandidates(base, exts) {
    let out = [];
    for (let ext of exts) {
      if (base.endsWith(ext)) {
        out.push(base.replace(ext, `.min${ext}`));
        out.push(base);
      }
    }
    return out;
  }
  function autoLoadWaveSettingCSS() {
    if (waveSettingLoaded) return;
    for (const link of document.querySelectorAll('link[rel="stylesheet"]')) {
      if (link.href && /wave-setting(\.min)?\.css([?#].*)?$/i.test(link.href)) {
        waveSettingLoaded = true; return;
      }
    }
    const pathBases = [
      '/wave-setting.css',
      '/css/wave-setting.css',
      '/assets/wave-setting.css'
    ];
    let candidates = [];
    for (const base of pathBases) {
      candidates = candidates.concat(makeMultifyCandidates(base, [".css"]));
    }
    const thisScript = document.currentScript || Array.from(document.scripts).find(s=>/wave-effect(\.min)?\.js$/i.test(s.src));
    if (thisScript && thisScript.src) {
      try {
        const url = new URL(thisScript.src, location.href);
        url.pathname = url.pathname.replace(/[^/]+$/, 'wave-setting.css');
        candidates = candidates.concat(makeMultifyCandidates(url.pathname, [".css"]));
      } catch {}
    }
    (function tryNext(idx){
      if (idx >= candidates.length) return;
      const href = candidates[idx];
      if (document.querySelector(`link[href="${href}"]`)) return tryNext(idx+1);
      const link = document.createElement('link');
      link.rel = 'stylesheet'; link.href = href;
      link.onload = () => { waveSettingLoaded = true; };
      link.onerror = () => { tryNext(idx+1); };
      document.head.appendChild(link);
    })(0);
  }
  function autoLoadWaveSettingJSON(callback) {
    if (waveJsonLoaded) { if (callback) callback(settings); return; }
    const pathBases = [
      '/wave-setting.json',
      '/css/wave-setting.json',
      '/assets/wave-setting.json'
    ];
    let candidates = [];
    for (const base of pathBases) {
      candidates = candidates.concat(makeMultifyCandidates(base, [".json"]));
    }
    const thisScript = document.currentScript || Array.from(document.scripts).find(s=>/wave-effect(\.min)?\.js$/i.test(s.src));
    if (thisScript && thisScript.src) {
      try {
        const url = new URL(thisScript.src, location.href);
        url.pathname = url.pathname.replace(/[^/]+$/, 'wave-setting.json');
        candidates = candidates.concat(makeMultifyCandidates(url.pathname, [".json"]));
      } catch {}
    }
    (function tryNext(idx){
      if (idx >= candidates.length) {
        waveJsonLoaded = true; if (callback) callback(settings); return;
      }
      fetch(candidates[idx], {method:'GET', credentials:'same-origin'})
        .then(r => r.ok ? r.json() : null)
        .then(json => {
          if (json && typeof json === 'object') {
            waveJsonLoaded = true; Object.assign(settings, json);
            if (callback) callback(settings);
          } else { tryNext(idx+1); }
        })
        .catch(()=>tryNext(idx+1));
    })(0);
  }

  let tapHighlightInjected = false;
  function injectTapHighlightCSS() {
    if (tapHighlightInjected) return;
    if (document.querySelector('[data-wave-tap-highlight="true"]')) { tapHighlightInjected = true; return; }
    const style = document.createElement("style");
    style.setAttribute("data-wave-tap-highlight", "true");
    style.textContent = `[wave]{-webkit-tap-highlight-color:transparent!important;tap-highlight-color:transparent!important;}`;
    document.head.appendChild(style);
    tapHighlightInjected = true;
  }

  function getDefaultRippleColor(el) {
    let node = el;
    while (node) {
      const style = getComputedStyle(node);
      const val = style.getPropertyValue('--ripple-default-color').trim();
      if (val) return val;
      node = node.parentElement;
    }
    return null;
  }

  function getRippleColor(el) {
    if (el.hasAttribute('data-ripple-color')) {
      let val = el.getAttribute('data-ripple-color').trim();
      if (val) return val;
    }
    const attr = el.getAttribute("wave") || "";
    let m = attr.match(/(?:^|\s)c\s*[=:]?\s*([#a-zA-Z0-9(),.\s]+)/i);
    if (m && m[1]) {
      let val = m[1].trim();
      if (val) return val;
    }
    let def = getDefaultRippleColor(el);
    if (def) return def;
    return null;
  }

  function getRippleBg(color) {
    const defaultC = [16, 20, 28];
    if (color) {
      if (/^rgba?\([^)]+\)$/i.test(color) || /^hsla?\([^)]+\)$/i.test(color)) {
        let main = color.replace(/\s+/g,'');
        let inside = main.match(/\(([^)]+)\)/);
        if (inside) {
          let parts = inside[1].split(',');
          let alpha = parts[3] !== undefined ? parseFloat(parts[3]) : 1;
          let p1 = Math.min(1, Math.max(alpha, 0.13));
          let p2 = Math.max(0, 0.6 * p1);
          let p3 = Math.max(0, 0.09 * p1);
          let c1 = parts.slice(0,3).join(',') + ',' + p1;
          let c2 = parts.slice(0,3).join(',') + ',' + p2;
          let c3 = parts.slice(0,3).join(',') + ',' + p3;
          let prefix = color.startsWith('hsla') ? 'hsla' : (color.startsWith('hsl') ? 'hsla' : 'rgba');
          return `radial-gradient(circle, ${prefix}(${c1}) 62%, ${prefix}(${c2}) 74%, ${prefix}(${c3}) 100%)`;
        }
      }
      return `radial-gradient(circle, ${color}21 62%, ${color}13 74%, ${color}03 100%)`;
    }
    return `radial-gradient(circle, rgba(${defaultC[0]},${defaultC[1]},${defaultC[2]},0.13) 62%, rgba(${defaultC[0]},${defaultC[1]},${defaultC[2]},0.078) 74%, rgba(${defaultC[0]},${defaultC[1]},${defaultC[2]},0.03) 100%)`;
  }

  function maximalExpandedCoverageRadius(x, y, width, height) {
    let dists = [
      x, y, width - x, height - y,
      Math.hypot(x, y), Math.hypot(width - x, y), Math.hypot(x, height - y), Math.hypot(width - x, height - y),
      Math.abs(width/2 - x), Math.abs(height/2 - y), Math.hypot(width, height) / 2
    ];
    let maxDist = Math.max(...dists);
    let expand = Math.max(width, height) * COVERAGE_EXPAND_RATIO;
    let minRadius = 28;
    return Math.max(maxDist * Math.SQRT2 + expand, minRadius);
  }

  function smartBlur() { return `blur(${RIPPLE_HALO_BLUR}px)`; }

  function smartDuration(x, y, width, height) {
    const cx = width / 2, cy = height / 2;
    const maxDist = maximalExpandedCoverageRadius(cx, cy, width, height);
    const pointerDist = Math.hypot(x - cx, y - cy);
    const ratio = Math.min(pointerDist / maxDist, 1);
    const duration = BASE_DURATION - (BASE_DURATION - MIN_DURATION) * (ratio * MAX_EXTRA);
    return Math.round(duration);
  }

  function fadeOutAndRemoveRipple(ripple, fadeType, el) {
    if (!ripple) return;
    let duration = (fadeType === 'auto' ? RIPPLE_FADE_DURATION_AUTO : RIPPLE_FADE_DURATION_MANUAL);
    ripple.classList.add('fading');
    ripple.style.setProperty('--ripple-fade-duration', duration + 'ms');
    ripple.style.willChange = 'opacity,transform,filter';
    let removed = false;
    function removeRippleAfterFade(e) {
      if (removed) return;
      if (!e || e.propertyName === "opacity") {
        removed = true;
        ripple.removeEventListener('transitionend', removeRippleAfterFade);
        ripple.style.removeProperty('will-change');
        releaseRippleNode(el, ripple);
        globalActiveWavesCount = Math.max(0, globalActiveWavesCount-1);
      }
    }
    ripple.addEventListener('transitionend', removeRippleAfterFade);
    setTimeout(removeRippleAfterFade, duration + 100);
  }

  function clearRipples(el) {
    const ripples = el.querySelectorAll('.' + RIPPLE_CLASS);
    ripples.forEach(r => { fadeOutAndRemoveRipple(r, 'manual', el); });
    activeRipples.set(el, null);
  }

  function allowGlobalRipple() {
    const now = performance.now();
    if (now - lastGlobalRippleTime < GLOBAL_MIN_RIPPLE_INTERVAL) return false;
    if (globalActiveWavesCount >= GLOBAL_MAX_RIPPLES) return false;
    lastGlobalRippleTime = now;
    globalActiveWavesCount++;
    return true;
  }

  // --- Minimized getBoundingClientRect usage
  const rectCache = new WeakMap();
  function getRect(el) {
    let cached = rectCache.get(el);
    const now = performance.now();
    if (!cached || (now - cached.time > 500)) { // 500ms cache window
      cached = { rect: el.getBoundingClientRect(), time: now };
      rectCache.set(el, cached);
    }
    return cached.rect;
  }

  // --- Main pointer handler (enhanced for finger intent/scroll analysis)
  function shouldBlockRipple(e) {
    // 1. If rapid scrolling
    if (isRapidScrolling || advancedScrollAnalysis.rapid) return true;
    // 2. If finger intent says cancel
    if (e && (e.type === 'touchstart' || e.type === 'touchend' || e.type === 'touchmove')) {
      if (fingerIntent.cancelRipple || fingerIntent.cancelByMove) return true;
      // If fingerDown, but has moved far, block
      // (Already handled by cancelByMove)
    }
    // 3. If pointer event, try to detect if user is panning/scrolling with touch
    if (e && e.pointerType && e.pointerType === 'touch') {
      // If finger moved a lot before pointerdown, block
      if (fingerIntent.cancelRipple || fingerIntent.cancelByMove) return true;
    }
    return false;
  }

  function onPointerDown(e) {
    // Enhanced: block on any scroll/finger intent
    if (shouldBlockRipple(e)) return;
    if (e.button && e.button !== 0) return;
    const el = this;
    if (!allowGlobalRipple()) return;
    const now = performance.now();
    const last = lastAllowed.get(el) || 0;
    if (now - last < MIN_RIPPLE_INTERVAL) {
      globalActiveWavesCount = Math.max(0, globalActiveWavesCount-1); return;
    }
    if (activeRipples.get(el)) {
      globalActiveWavesCount = Math.max(0, globalActiveWavesCount-1); return;
    }
    lastAllowed.set(el, now);

    scheduleRipple(() => {
      const rect = getRect(el);
      const pointer = e.touches?.[0] || e;
      const x = pointer.clientX - rect.left;
      const y = pointer.clientY - rect.top;
      const radius = maximalExpandedCoverageRadius(x, y, rect.width, rect.height);
      const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
      const duration = smartDuration(x, y, rect.width, rect.height);
      const colorVal = getRippleColor(el);
      const bg = getRippleBg(colorVal);

      const ripple = getRippleNode(el);
      ripple.style.width = ripple.style.height = `${RIPPLE_HALO_START_DIAMETER}px`;
      ripple.style.left = `${x - RIPPLE_HALO_START_DIAMETER/2}px`;
      ripple.style.top = `${y - RIPPLE_HALO_START_DIAMETER/2}px`;
      ripple.style.setProperty('--ripple-duration', duration + 'ms');
      ripple.style.setProperty('--ripple-blur', smartBlur());
      ripple.style.background = bg;
      ripple.style.setProperty('--ripple-final-scale', haloFinalScale);
      ripple.style.willChange = 'opacity,transform,filter';

      el.appendChild(ripple);
      activeRipples.set(el, ripple);

      let animationEnded = false;
      let autoFadeTimeout = null;

      function endRipple() {
        if (!ripple.parentNode) return;
        if (!animationEnded) {
          fadeOutAndRemoveRipple(ripple, 'auto', el);
        } else {
          fadeOutAndRemoveRipple(ripple, 'manual', el);
        }
        activeRipples.set(el, null);
        if (autoFadeTimeout) clearTimeout(autoFadeTimeout);
        el.removeEventListener('pointerup', endRipple);
        el.removeEventListener('pointerleave', endRipple);
        el.removeEventListener('touchend', endRipple);
        el.removeEventListener('touchcancel', endRipple);
      }
      el.addEventListener('pointerup', endRipple, {passive:true, once:true});
      el.addEventListener('pointerleave', endRipple, {passive:true, once:true});
      el.addEventListener('touchend', endRipple, {passive:true, once:true});
      el.addEventListener('touchcancel', endRipple, {passive:true, once:true});

      requestAnimationFrame(()=>{
        ripple.classList.add('animating');
        ripple.style.transform = `scale(var(--ripple-final-scale, 1))`;
        setTimeout(()=>{ animationEnded = true; }, duration);
      });

      autoFadeTimeout = setTimeout(() => {}, duration + 30);
    });
  }

  function onKeyDown(e) {
    if (![' ', 'Enter'].includes(e.key)) return;
    const el = this;
    clearRipples(el);
    if (!allowGlobalRipple()) return;
    scheduleRipple(() => {
      const rect = getRect(el);
      const x = rect.width / 2, y = rect.height / 2;
      const radius = maximalExpandedCoverageRadius(x, y, rect.width, rect.height);
      const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
      const duration = BASE_DURATION;
      const colorVal = getRippleColor(el);
      const bg = getRippleBg(colorVal);
      const ripple = getRippleNode(el);
      ripple.style.width = ripple.style.height = `${RIPPLE_HALO_START_DIAMETER}px`;
      ripple.style.left = `${rect.width/2 - RIPPLE_HALO_START_DIAMETER/2}px`;
      ripple.style.top = `${rect.height/2 - RIPPLE_HALO_START_DIAMETER/2}px`;
      ripple.style.setProperty('--ripple-duration', duration + 'ms');
      ripple.style.setProperty('--ripple-blur', smartBlur());
      ripple.style.background = bg;
      ripple.style.setProperty('--ripple-final-scale', haloFinalScale);
      ripple.style.willChange = 'opacity,transform,filter';
      el.appendChild(ripple);
      activeRipples.set(el, ripple);
      requestAnimationFrame(()=>{
        ripple.classList.add('animating');
        ripple.style.transform = `scale(var(--ripple-final-scale, 1))`;
      });
      setTimeout(()=>{
        fadeOutAndRemoveRipple(ripple, 'auto', el);
        activeRipples.set(el, null);
      }, duration - 140);
      lastAllowed.set(el, performance.now());
    });
  }

  // --- IntersectionObserver for only visible elements
  let observer;
  function observeDom() {
    if (observer) return;
    observer = new IntersectionObserver(entries => {
      for (const entry of entries) {
        if (entry.isIntersecting) {
          upgradeElement(entry.target);
        }
      }
    }, {threshold:0.01});
    document.querySelectorAll('[wave]').forEach(el=>observer.observe(el));
  }

  // --- UpgradeElement: use WeakSet
  function upgradeElement(el) {
    if (upgradedElements.has(el)) return;
    el.classList.add(SURFACE_CLASS);
    upgradedElements.add(el);
    if (settings.disableTapHighlight) injectTapHighlightCSS();
  }

  // --- upgradeAll: debounce + idle + cache
  let upgradeAllTimer = null;
  function upgradeAll() {
    if (upgradeAllTimer) return;
    upgradeAllTimer = true;
    const runner = () => {
      const nodes = querySelectorAllCached('[wave]');
      for (let el of nodes) upgradeElement(el);
      if (settings.disableTapHighlight) injectTapHighlightCSS();
      upgradeAllTimer = null;
    };
    if ('requestIdleCallback' in window) {
      requestIdleCallback(runner, {timeout: 200});
    } else {
      setTimeout(runner, 16);
    }
  }

  // --- Global handlers (event delegation)
  function globalPointerHandler(e) {
    if (e.button && e.button !== 0) return;
    let el = e.target.closest('[wave]');
    if (!el || !document.body.contains(el)) return;
    if (!upgradedElements.has(el)) upgradeElement(el);
    onPointerDown.call(el, e);
  }
  function globalKeyHandler(e) {
    let el = e.target.closest('[wave]');
    if (!el || !document.body.contains(el)) return;
    if (!upgradedElements.has(el)) upgradeElement(el);
    onKeyDown.call(el, e);
  }
  function installGlobalHandlers() {
    if (installGlobalHandlers.done) return;
    document.addEventListener('pointerdown', globalPointerHandler, {passive:true});
    document.addEventListener('keydown', globalKeyHandler, {passive:true, capture:true});
    installGlobalHandlers.done = true;
  }

  function initWakeEffect() {
    autoLoadWaveEffectCSS();
    autoLoadWaveSettingCSS();
    autoLoadWaveSettingJSON(function(opts){
      if (opts && opts.disableTapHighlight) injectTapHighlightCSS();
      upgradeAll();
    });
    upgradeAll();
    observeDom();
    installGlobalHandlers();
    window.addEventListener('beforeunload', ()=>{
      lastGlobalRippleTime = 0;
      globalActiveWavesCount = 0;
    });
  }

  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initWakeEffect, {once:true});
    } else {
      initWakeEffect();
    }
  }

  // --- Developer API
  const config = {
    BASE_DURATION,
    MIN_DURATION,
    MAX_EXTRA,
    MIN_RIPPLE_INTERVAL,
    GLOBAL_MIN_RIPPLE_INTERVAL,
    GLOBAL_MAX_RIPPLES,
    RIPPLE_HALO_START_DIAMETER,
    COVERAGE_EXPAND_RATIO,
    get RIPPLE_FADE_DURATION_AUTO() { return RIPPLE_FADE_DURATION_AUTO; },
    get RIPPLE_FADE_DURATION_MANUAL() { return RIPPLE_FADE_DURATION_MANUAL; },
    setFadeDurationAuto(ms) {
      if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_AUTO = ms|0;
    },
    setFadeDurationManual(ms) {
      if (typeof ms === 'number' && ms > 50 && ms < 5000) RIPPLE_FADE_DURATION_MANUAL = ms|0;
    }
  };

  return {
    upgradeAll,
    upgradeElement,
    clearRipples,
    config,
    settings
  };
}));