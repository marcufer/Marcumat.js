/**
 * wake-effect.js (IMPROVED FOR SMALLER RIPPLE)
 * - Pro Material Ripple Effect, better cross-site compatibility, fallback CSS
 * - Improved specificity, fallback style, smoother halo scale, more robust in real use.
 * @version 2.4.0
 */
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = factory();
  } else {
    root.WakeEffect = factory();
  }
}(typeof self !== 'undefined' ? self : this, function() {
  'use strict';

  // --- Configurable main parameters ---
  const RIPPLE_CLASS = 'ripple';
  const SURFACE_CLASS = 'ripple-surface';
  const BASE_DURATION = 490;
  const MIN_DURATION = 370;
  const MAX_EXTRA = 0.17;
  const MIN_RIPPLE_INTERVAL = 150;
  const GLOBAL_MIN_RIPPLE_INTERVAL = 100;
  const GLOBAL_MAX_RIPPLES = 7;
  const RIPPLE_CENTER_DIAMETER = 18;
  const RIPPLE_HALO_START_DIAMETER = 18;
  const RIPPLE_HALO_OPACITY = 0.14;
  const RIPPLE_HALO_END_OPACITY = 0.008;
  const RIPPLE_HALO_BLUR = 0.8;
  const COVERAGE_EXPAND_RATIO = 0.35;
  let lastGlobalRippleTime = 0;
  let globalActiveWavesCount = 0;
  const lastAllowed = new WeakMap();
  const activeRipples = new WeakMap();
  let wakeSettingLoaded = false;
  let wakeJsonLoaded = false;
  let wakeEffectCSSLoaded = false;
  let settings = { disableTapHighlight: false };

  // --- Fallback Style Injection ---
  function ensureRippleStyles() {
    const test = document.createElement('span');
    test.className = 'ripple';
    test.style.display = 'none';
    document.body.appendChild(test);
    const computed = getComputedStyle(test);
    const ok = computed.transitionDuration !== '' && (computed.borderRadius === '50%' || computed.borderRadius === '50% 50%');
    document.body.removeChild(test);
    if (!ok) {
      // Inject fallback style inline
      const style = document.createElement('style');
      style.textContent = `
body .ripple-surface, .ripple-surface { position:relative; overflow:hidden!important; z-index:0; }
body .ripple, .ripple { pointer-events:none; position:absolute; border-radius:50%!important; width:18px; height:18px; opacity:1; will-change:transform,opacity,filter; filter:blur(0.8px); transition:transform 490ms cubic-bezier(0.32,0,0.53,1), opacity 1200ms cubic-bezier(0.4,0,0.2,1), filter 70ms cubic-bezier(0.4,0,0.2,1); background:radial-gradient(circle,rgba(33,150,243,0.10) 74%,rgba(33,150,243,0.008) 100%);}
body .ripple.fading, .ripple.fading { opacity:0; }
      `;
      document.head.appendChild(style);
    }
  }

  function makeMultifyCandidates(base, exts) {
    let out = [];
    for (let ext of exts) {
      if (base.endsWith(ext)) {
        out.push(base.replace(ext, `.min${ext}`));
        out.push(base);
      }
    }
    return out;
  }

  function autoLoadWakeEffectCSS() {
    if (wakeEffectCSSLoaded) return;
    for (const link of document.querySelectorAll('link[rel="stylesheet"]')) {
      if (link.href && /wake-effect\.min\.css([?#].*)?$/i.test(link.href)) {
        wakeEffectCSSLoaded = true;
        return;
      }
    }
    const candidates = [
      '/wake-effect.min.css',
      '/css/wake-effect.min.css',
      '/assets/wake-effect.min.css'
    ];
    const thisScript = document.currentScript || Array.from(document.scripts).find(s=>/wake-effect(\.min)?\.js$/i.test(s.src));
    if (thisScript && thisScript.src) {
      try {
        const url = new URL(thisScript.src, location.href);
        url.pathname = url.pathname.replace(/[^/]+$/, 'wake-effect.min.css');
        candidates.push(url.pathname + url.search + url.hash);
      } catch {}
    }
    (function tryNext(idx){
      if (idx >= candidates.length) { ensureRippleStyles(); return; }
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = candidates[idx];
      link.onload = function(){wakeEffectCSSLoaded=true;};
      link.onerror = function(){tryNext(idx+1);};
      if (!document.querySelector(`link[href="${link.href}"]`)) {
        document.head.appendChild(link);
      }
    })(0);
  }

  function autoLoadWakeSettingCSS() {
    if (wakeSettingLoaded) return;
    for (const link of document.querySelectorAll('link[rel="stylesheet"]')) {
      if (link.href && /wake-setting(\.min)?\.css([?#].*)?$/i.test(link.href)) {
        wakeSettingLoaded = true;
        return;
      }
    }
    const pathBases = [
      '/wake-setting.css',
      '/css/wake-setting.css',
      '/assets/wake-setting.css'
    ];
    let candidates = [];
    for (const base of pathBases) {
      candidates = candidates.concat(makeMultifyCandidates(base, [".css"]));
    }
    const thisScript = document.currentScript || Array.from(document.scripts).find(s=>/wake-effect(\.min)?\.js$/i.test(s.src));
    if (thisScript && thisScript.src) {
      try {
        const url = new URL(thisScript.src, location.href);
        url.pathname = url.pathname.replace(/[^/]+$/, 'wake-setting.css');
        candidates = candidates.concat(makeMultifyCandidates(url.pathname, [".css"]));
      } catch {}
    }
    (function tryNext(idx){
      if (idx >= candidates.length) return;
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = candidates[idx];
      link.onload = function(){wakeSettingLoaded=true;};
      link.onerror = function(){tryNext(idx+1);};
      if (!document.querySelector(`link[href="${link.href}"]`)) {
        document.head.appendChild(link);
      }
    })(0);
  }

  function autoLoadWakeSettingJSON(callback) {
    if (wakeJsonLoaded) {
      if (callback) callback(settings);
      return;
    }
    const pathBases = [
      '/wake-setting.json',
      '/css/wake-setting.json',
      '/assets/wake-setting.json'
    ];
    let candidates = [];
    for (const base of pathBases) {
      candidates = candidates.concat(makeMultifyCandidates(base, [".json"]));
    }
    const thisScript = document.currentScript || Array.from(document.scripts).find(s=>/wake-effect(\.min)?\.js$/i.test(s.src));
    if (thisScript && thisScript.src) {
      try {
        const url = new URL(thisScript.src, location.href);
        url.pathname = url.pathname.replace(/[^/]+$/, 'wake-setting.json');
        candidates = candidates.concat(makeMultifyCandidates(url.pathname, [".json"]));
      } catch {}
    }
    (function tryNext(idx){
      if (idx >= candidates.length) {
        wakeJsonLoaded = true;
        if (callback) callback(settings);
        return;
      }
      fetch(candidates[idx], {method:'GET', credentials:'same-origin'})
        .then(r => r.ok ? r.json() : null)
        .then(json => {
          if (json && typeof json === 'object') {
            wakeJsonLoaded = true;
            Object.assign(settings, json);
            if (callback) callback(settings);
          } else {
            tryNext(idx+1);
          }
        })
        .catch(()=>tryNext(idx+1));
    })(0);
  }

  let tapHighlightInjected = false;
  function injectTapHighlightCSS() {
    if (tapHighlightInjected) return;
    const style = document.createElement("style");
    style.setAttribute("data-wake-tap-highlight", "true");
    style.textContent = `[wake]{-webkit-tap-highlight-color:transparent!important;tap-highlight-color:transparent!important;}`;
    document.head.appendChild(style);
    tapHighlightInjected = true;
  }

  // --- Core logic (center always fixed, halo expands) ---
  function getDefaultRippleColor(el) {
    let node = el;
    while (node) {
      const style = getComputedStyle(node);
      const val = style.getPropertyValue('--ripple-default-color').trim();
      if (val) return val;
      node = node.parentElement;
    }
    return null;
  }
  function getRippleColor(el) {
    if (el.hasAttribute('data-ripple-color')) {
      let val = el.getAttribute('data-ripple-color').trim();
      if (val) return val;
    }
    const attr = el.getAttribute("wake") || "";
    let m = attr.match(/(?:^|\s)c\s*[=:]?\s*([#a-zA-Z0-9(),.\s]+)/i);
    if (m && m[1]) {
      let val = m[1].trim();
      if (val) return val;
    }
    let def = getDefaultRippleColor(el);
    if (def) return def;
    return null;
  }
  function getRippleBg(color) {
    if (color) {
      if (/^rgba?\([^)]+\)$/i.test(color) || /^hsla?\([^)]+\)$/i.test(color)) {
        let main = color.replace(/\s+/g,'');
        let inside = main.match(/\(([^)]+)\)/);
        if (inside) {
          let parts = inside[1].split(',');
          let alpha = parts[3] !== undefined ? parseFloat(parts[3]) : 1;
          let p1 = Math.min(1, Math.max(alpha, 0.20));
          let p2 = Math.max(0, 0.50 * p1);
          let p3 = Math.max(0, 0.04 * p1);
          let c1 = parts.slice(0,3).join(',') + ',' + p1;
          let c2 = parts.slice(0,3).join(',') + ',' + p2;
          let c3 = parts.slice(0,3).join(',') + ',' + p3;
          let prefix = color.startsWith('hsla') ? 'hsla' : (color.startsWith('hsl') ? 'hsla' : 'rgba');
          return `radial-gradient(circle, ${prefix}(${c1}) 62%, ${prefix}(${c2}) 74%, ${prefix}(${c3}) 100%)`;
        }
      }
      return `radial-gradient(circle, ${color}33 62%, ${color}19 74%, ${color}02 100%)`;
    }
    return `radial-gradient(circle, rgba(255,255,255,0.20) 62%, rgba(255,255,255,0.10) 74%, rgba(255,255,255,0.008) 100%)`;
  }

  // Improved: use smaller halo for mobile/fat padding
  function maximalExpandedCoverageRadius(x, y, width, height) {
    const dx = Math.max(x, width - x);
    const dy = Math.max(y, height - y);
    // ลดขนาด halo ให้เล็กลง เหมาะกับปุ่มสมัยใหม่
    return Math.sqrt(dx*dx + dy*dy) * 0.60 + 6;
  }
  function smartBlur() { return `blur(${RIPPLE_HALO_BLUR}px)`; }
  function smartDuration(x, y, width, height) {
    const cx = width / 2, cy = height / 2;
    const maxDist = maximalExpandedCoverageRadius(cx, cy, width, height);
    const pointerDist = Math.hypot(x - cx, y - cy);
    const ratio = Math.min(pointerDist / maxDist, 1);
    const duration = BASE_DURATION - (BASE_DURATION - MIN_DURATION) * (ratio * MAX_EXTRA);
    return Math.round(duration);
  }
  function clearRipples(el) {
    const ripples = el.querySelectorAll('.' + RIPPLE_CLASS);
    ripples.forEach(r => {
      r.classList.add('fading');
      setTimeout(()=>{
        r.remove();
        globalActiveWavesCount = Math.max(0, globalActiveWavesCount-1);
      }, 750);
    });
    activeRipples.set(el, null);
  }
  function allowGlobalRipple() {
    const now = performance.now();
    if (now - lastGlobalRippleTime < GLOBAL_MIN_RIPPLE_INTERVAL) return false;
    if (globalActiveWavesCount >= GLOBAL_MAX_RIPPLES) return false;
    lastGlobalRippleTime = now;
    globalActiveWavesCount++;
    return true;
  }
  function onPointerDown(e) {
    if (e.button && e.button !== 0) return;
    const el = e.currentTarget;
    if (!allowGlobalRipple()) return;
    const now = performance.now();
    const last = lastAllowed.get(el) || 0;
    if (now - last < MIN_RIPPLE_INTERVAL) {
      globalActiveWavesCount = Math.max(0, globalActiveWavesCount-1);
      return;
    }
    if (activeRipples.get(el)) {
      globalActiveWavesCount = Math.max(0, globalActiveWavesCount-1);
      return;
    }
    lastAllowed.set(el, now);

    const pointer = e.touches?.[0] || e;
    const rect = el.getBoundingClientRect();
    const x = pointer.clientX - rect.left;
    const y = pointer.clientY - rect.top;

    // Always render at fixed size for center, but animate a faint expanding halo for the edge
    const radius = maximalExpandedCoverageRadius(x, y, rect.width, rect.height);
    const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
    const cappedScale = Math.min(1.4, haloFinalScale); // จำกัด scale ไม่เกิน 1.4 เท่า
    const duration = smartDuration(x, y, rect.width, rect.height);
    const colorVal = getRippleColor(el);
    const bg = getRippleBg(colorVal);

    const ripple = document.createElement('span');
    ripple.className = RIPPLE_CLASS + ' dynamic-halo-pro';
    ripple.style.width = ripple.style.height = `${RIPPLE_HALO_START_DIAMETER}px`;
    ripple.style.left = `${x - RIPPLE_HALO_START_DIAMETER/2}px`;
    ripple.style.top = `${y - RIPPLE_HALO_START_DIAMETER/2}px`;
    ripple.style.setProperty('--ripple-duration', duration + 'ms');
    ripple.style.setProperty('--ripple-blur', smartBlur());
    ripple.style.background = bg;
    ripple.style.setProperty('--ripple-final-scale', cappedScale);

    el.appendChild(ripple);
    activeRipples.set(el, ripple);

    requestAnimationFrame(()=>{
      ripple.classList.add('animating');
      ripple.style.transform = `scale(var(--ripple-final-scale, 1))`;
    });

    function endRipple(){
      ripple.classList.add('fading');
      setTimeout(()=>{
        ripple.remove();
        globalActiveWavesCount = Math.max(0, globalActiveWavesCount-1);
      }, 750);
      activeRipples.set(el, null);
      el.removeEventListener('pointerup', endRipple);
      el.removeEventListener('pointerleave', endRipple);
      el.removeEventListener('touchend', endRipple);
      el.removeEventListener('touchcancel', endRipple);
    }
    el.addEventListener('pointerup', endRipple);
    el.addEventListener('pointerleave', endRipple);
    el.addEventListener('touchend', endRipple);
    el.addEventListener('touchcancel', endRipple);
  }
  function onKeyDown(e) {
    if (![' ', 'Enter'].includes(e.key)) return;
    const el = e.currentTarget;
    clearRipples(el);

    if (!allowGlobalRipple()) return;

    const rect = el.getBoundingClientRect();
    const x = rect.width / 2, y = rect.height / 2;
    const radius = maximalExpandedCoverageRadius(x, y, rect.width, rect.height);
    const haloFinalScale = (radius * 2) / RIPPLE_HALO_START_DIAMETER;
    const cappedScale = Math.min(1.4, haloFinalScale);
    const duration = BASE_DURATION;
    const colorVal = getRippleColor(el);
    const bg = getRippleBg(colorVal);
    const ripple = document.createElement('span');
    ripple.className = RIPPLE_CLASS + ' dynamic-halo-pro';
    ripple.style.width = ripple.style.height = `${RIPPLE_HALO_START_DIAMETER}px`;
    ripple.style.left = `${rect.width/2 - RIPPLE_HALO_START_DIAMETER/2}px`;
    ripple.style.top = `${rect.height/2 - RIPPLE_HALO_START_DIAMETER/2}px`;
    ripple.style.setProperty('--ripple-duration', duration + 'ms');
    ripple.style.setProperty('--ripple-blur', smartBlur());
    ripple.style.background = bg;
    ripple.style.setProperty('--ripple-final-scale', cappedScale);
    el.appendChild(ripple);
    requestAnimationFrame(()=>{
      ripple.classList.add('animating');
      ripple.style.transform = `scale(var(--ripple-final-scale, 1))`;
    });
    setTimeout(()=>{
      ripple.classList.add('fading');
      setTimeout(()=>{
        ripple.remove();
        globalActiveWavesCount = Math.max(0, globalActiveWavesCount-1);
      }, 750);
    }, duration - 140);
    activeRipples.set(el, null);
    lastAllowed.set(el, performance.now());
  }
  function upgradeAll() {
    document.querySelectorAll('[wake]').forEach(upgradeElement);
    if (settings.disableTapHighlight) injectTapHighlightCSS();
  }
  function upgradeElement(el) {
    if (el.classList.contains(SURFACE_CLASS)) return;
    el.classList.add(SURFACE_CLASS);
    el.addEventListener('pointerdown', onPointerDown, {passive:true});
    el.addEventListener('keydown', onKeyDown);
    if (settings.disableTapHighlight) injectTapHighlightCSS();
  }
  function initWakeEffect() {
    autoLoadWakeEffectCSS();
    autoLoadWakeSettingCSS();
    autoLoadWakeSettingJSON(function(opts){
      if (opts && opts.disableTapHighlight) injectTapHighlightCSS();
      upgradeAll();
    });
    upgradeAll();
    ensureRippleStyles();
    new MutationObserver(upgradeAll).observe(document.documentElement, {
      subtree:true, childList:true, attributes:true, attributeFilter:['wake','data-ripple-color']
    });
    window.addEventListener('beforeunload', ()=>{
      lastGlobalRippleTime = 0;
      globalActiveWavesCount = 0;
    });
  }
  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initWakeEffect, {once:true});
    } else {
      initWakeEffect();
    }
  }
  return {
    upgradeAll,
    upgradeElement,
    clearRipples,
    config: {
      BASE_DURATION,
      MIN_DURATION,
      MAX_EXTRA,
      MIN_RIPPLE_INTERVAL,
      GLOBAL_MIN_RIPPLE_INTERVAL,
      GLOBAL_MAX_RIPPLES,
      RIPPLE_CENTER_DIAMETER,
      RIPPLE_HALO_START_DIAMETER,
      COVERAGE_EXPAND_RATIO
    },
    settings
  };
}));